---
layout: post
title: "【CS50X】"
author: LJC
tags:
- cs50
date: 2022-12-02 13:00 +0800
toc: true
---

## Week 3：Algorithm

关于选举的 [Tideman](https://cs50.harvard.edu/x/2022/psets/3/tideman/) 算法的 C 实现：
- 将每个候选者两两分成 pair ；
- pair 类含有 winner 和 loser，计所有选票后，（仅对这两个人而言）支持人数更多的为 winner ，并得到 pairs[ ] 数组;
-  pairs[ ] 数组按胜利强度排序（支持 winner 的人数 - 支持 loser 的人数），将得到一系列边 (winner -> loser) **从 winner 出发指向 loser** ；
- 按胜利强度将边加入到图中，得到有向图的邻接矩阵
    - 注意：每次加入有向边都要 **检查此时有向图是否成环 (Detect Cycle in a Directed Graph)** ;
- 最后，没有被箭头指向的候选者将获胜；

如何根据此时的邻接矩阵实现有向图环路检测？

思路如下：

- ![cs50-1.png](/images/cs50-1.png "有向图环路检测")

代码如下：

- ![cs50-2.png](/images/cs50-2.png "有向图环路检测-代码")

## Week 4：Memory

编译器不会检查内存相关的错误，为此可以使用 Valgrind 来检查内存泄漏等错误：
- ![cs50-3.png](/images/cs50-3.png "Valgrind检测")

另外，注意：**函数的输入是一个副本**。一个典型例子是交换 swap 函数，输入 x 和 y 两个变量，则只在函数内部交换了，因为函数的输入是一个副本。

一个错误示范的示意图：
- ![cs50-4.png](/images/cs50-4.png "错误示范")

正确的交换示意图：
- ![cs50-5.png](/images/cs50-5.png "对地址操作的正确示范")

Problem Set4 - Recover

代码如下，但经 valgrind 检查后发现存在内存问题：

> 472 bytes in 1 blocks are still reachable in loss record 1 of 1: (file: recover.c, line: 11)

{% highlight js %}
#include <stdio.h>
#include <stdlib.h>
#include <cs50.h>
#include <string.h>

int main(int argc, char *argv[])
{
    unsigned char buffer[512]={0};
    if (argc == 2)
    {
        FILE *raw_file = fopen(argv[1], "r");
        if (raw_file == NULL)
        {
            printf("Usage: ./recover IMAGE\n");
            return 1;
        }
        fclose(raw_file);
    }else
    {
        printf("Usage: ./recover IMAGE\n");
        return 1;
    }
    // handle file contents:
    FILE *raw_file = fopen(argv[1], "r");
    int cnt = 0;
    char s[8];
    FILE *fp = NULL;
    bool flag = false;
    while (fread(buffer, 1, 512, raw_file) == 512)
    {
        // read 512 Bytes one time
        if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff)
        {
            if (fp!=NULL)
            {
                fclose(fp);
            }
            // create a new file
            sprintf(s,"0%02u.jpg",cnt);
            cnt ++;
            fp = fopen(s, "w+");
            flag = true;
        }
        // write
        if (flag)
        {
            fwrite(buffer, sizeof(buffer), 1, fp);
        }

    }
    fclose(raw_file);
    fclose(fp);
}

{% endhighlight %}

所谓的内存泄露 **(Memory Leak)** 有两种：
- 一种是内存分配好了，但用过后没有 free 掉（本可以释放却没有）
- 另一种是内存分配后，**由于丢失了指向该内存的指针**因此无法 free （想释放也没法释放）

具体来讲，fopen 的要 fclose 掉，malloc 分配的要 free 掉。