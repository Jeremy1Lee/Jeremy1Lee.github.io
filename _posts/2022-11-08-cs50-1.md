---
layout: post
title: "【CS50X】"
author: LJC
tags:
- cs50
date: 2022-12-02 13:00 +0800
toc: true
---

## Week 3：Algorithm

关于选举的 [Tideman](https://cs50.harvard.edu/x/2022/psets/3/tideman/) 算法的 C 实现：
- 将每个候选者两两分成 pair ；
- pair 类含有 winner 和 loser，计所有选票后，（仅对这两个人而言）支持人数更多的为 winner ，并得到 pairs[ ] 数组;
-  pairs[ ] 数组按胜利强度排序（支持 winner 的人数 - 支持 loser 的人数），将得到一系列边 (winner -> loser) **从 winner 出发指向 loser** ；
- 按胜利强度将边加入到图中，得到有向图的邻接矩阵
    - 注意：每次加入有向边都要 **检查此时有向图是否成环 (Detect Cycle in a Directed Graph)** ;
- 最后，没有被箭头指向的候选者将获胜；

如何根据此时的邻接矩阵实现有向图环路检测？

思路如下：

- ![cs50-1.png](/images/cs50-1.png "有向图环路检测")

代码如下：

- ![cs50-2.png](/images/cs50-2.png "有向图环路检测-代码")

## Week 4：Memory

编译器不会检查内存相关的错误，为此可以使用 Valgrind 来检查内存泄漏等错误：
- ![cs50-3.png](/images/cs50-3.png "Valgrind检测")

另外，注意：**函数的输入是一个副本**。一个典型例子是交换 swap 函数，输入 x 和 y 两个变量，则只在函数内部交换了，因为函数的输入是一个副本。

一个错误示范的示意图：
- ![cs50-4.png](/images/cs50-4.png "错误示范")

正确的交换示意图：
- ![cs50-5.png](/images/cs50-5.png "对地址操作的正确示范")