---
layout: post
title: "多路查找树"
author: LJC
tags:
- Java
- Tree
date: 2022-10-07 22:00 +0800
toc: true
---
致力于解决高二叉树的效率问题。
{: .message }

## 二叉树与多叉树

### 二叉树存在的问题：高度太大，效率降低

二叉树需要加载到内存。如果二叉树节点少，没什么问题。但如果节点很多（1亿）就存在如下问题：

- 1）在构建二叉树时，需要**多次 i/o 操作**（节点可能来自文件，或数据库），构建速度有影响；

- 2）节点海量，也会造成二叉树的高度很高（即使是完美二叉树 2^n - 1 个对应 n 层），降低操作速度；

根本原因在于：**二叉树只有左子节点和右子节点！而且一个节点一个数据域！**

### 多叉树

二叉树每个节点有数据项，最多有两个节点。如果**允许每个节点有更多的数据项和更多的子节点**，就是多叉树；例如：2-3 树，2-3-4 树就是多叉树。通过重新组织节点，减少树的高度，能对二叉树进行优化。例如：

![multiTree.png](/images/multiTree.png "多叉树"){: .align-center}

### B 树

B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。图中的 o-o-o 都是节点，只是**一个节点存放多个数据项**，一个圆圈表示一个数据项，相连的数据项，整个表示一个节点，如黄色部分。 

![bTree.png](/images/bTree.png "B树"){: .align-center}

- B 树的优点是多的数据项减少了节点数量，降低树的高度。

- 文件系统及数据库系统的设计者利用了**磁盘预读原理**（预先读取数据），如果将一个节点的大小设为等于一个页（通常大小为 4K）

- 将树的度 M 设置为 1024 ，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素。B 树（B+ ）广泛应用于文件存储系统以及数据库系统中。可以在一个文档里快速找到数据。如：索引基于 B 树/ B+ 树

> 节点的度：一个节点的子节点个数。树的度：所有的节点里度最大的值（子节点最多）；

## 2-3 树

### 介绍

2-3 树是最简单的 B 树结构，具有如下特点：

- 2-3树的所有**叶子节点都在同一层**（只要是 B 树，都满足这个条件），也就是完美二叉树/满树/2^n - 1 个对应 n 层；

- 二节点：**要么有两个子节点，要么没有子节点**的节点；

- 三节点：**要么有三个子节点，要么没有子节点**的节点；

- 2-3 树是由**二节点**和**三节点**构成的树；

&emsp;&emsp;思考：既然是完美二叉树，非叶子肯定满节点（2/3），叶子肯定没节点，与上面的性质一道，这些特点也决定了如何构建 2-3 树。

### 构建 2-3 树图示

> 将数列 {16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。
 
保证大小顺序，即：仍然要满足排序树 (BST) 的特点：左 > 自己 > 右 （二节点）；左子 > 自己数据1 > 中子 > 自己数据2 > 右子 （三节点）。2-3 树的构建示意图如下：

![23tree01.png](/images/23tree01.png "1"){: .align-center}

![23tree02.png](/images/23tree02.png "2"){: .align-center}

注意这里看起来挤 24 上去也可以，但此时三节点的两个数据为 [16,24] ，那么没有对应的中子节点了，不符合规则，所以把 26 挤上去，让 24 成为中子节点，满足三节点有三个子节点。

![23tree03.png](/images/23tree03.png "3"){: .align-center}

添加 10 是最复杂的。因为父节点 [16, 26] 也满了，所以 [10, 12, 14] 这三个只能成为子树了，为了保证叶子节点同层，只能再从父节点拉下来一个节点多出一层，满足规则。

![23tree04.png](/images/23tree04.png "4"){: .align-center}

除了 2-3 树以外，还有 2-3-4 树等，也是一种 B 树，只是有 4 节点。

## B 树，B+ 树， B* 树

### B 树

**B-tree** 树即 B 树，B 是 Balanced 平衡的意思（这里的 B 不是 Binary ）。B- 树就是 B 树，是由 B-tree 翻译过来的，都是指的 B 树。上述 2-3 树， 2-3-4 树都是 B 树。在 Mysql 里经常听到某种类型的**索引是基于 B 树或者 B+ 树**的，这种数据库的底层是如何形成的？如图：

![btree02.png](/images/btree02.png "B树"){: .align-center}

关于B树，还有一些说明：
- B 树的阶：节点的**最多**子节点个数，比如 2-3 树的阶是3（由三节点贡献）， 2-3-4 树的阶是4；

- B 树的搜索：从根节点开始，对节点内的关键字（有序）进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点并重复，直到儿子节点为空（或已经是叶子节点）。 例如上图找 3 ，3 比 17 小，在左子 P1 找（P1 代表根二节点的左子，参考 Node 类的 left ），3 比 8 还小，再找它的 P1 ，找到了 3 ；

- 关键字集合分布在整棵树中，即**叶子节点和非叶子节点都存数据**；

- 搜索可能在非叶子节点就结束了；

- 搜索性能等价于在关键字全集内做一次二分查找(nlogn);

### B+ 树

在 MySQL 中，有些索引就是用 B 树或 B+ 树实现的。 B+ 树是 B 树的变体，也是一种多路搜索树。

![bp.png](/images/bp.png "B+树"){: .align-center}

如图，主要区别在于 B+ 树的**所有数据都放在叶子节点**，而不是非叶子节点。

- B+树只有到叶子节点才命中，性能也等价于在关键字全集做一次二分查找。

- 所有 **关键字都出现在叶子节点的链表中**，即：数据只能在叶子节点，也叫**稠密索引**，且链表的关键字（数据）恰好是有序的。如图：5-8-9 => 10-15-18 ...

- 不可能在非叶子节点命中。（注意图中上面的两个 5 是索引， 下面的 5 才是数据）

- 非叶子节点是叶子节点的索引（如图中框标记），也叫 **稀疏索引**。叶子节点是存储数据的数据层；

- B+ 树的这种结构更适合文件索引系统；

- B+ 树和 B 树不存在好坏问题，主要看各自的应用场景；

&emsp;&emsp;那么，为什么要设计这种结构？我们观察到数据域是 5，8，9， ... ， 96，99 ，如果用单链表存储，查找中间的 50 时效率非常低（回想四种查找方式）。于是我们自然地把数据分段，并提供算法告诉每一段各存什么范围的数据，这样再检索就是有目的的去找，而非盲目寻找，提高效率。

&emsp;&emsp;如图，第一个三节点把数据按 5-28-65 分成三段，第二个三节点按 5-10-20 再细分三段，一共分成了 9 段，图中我们一段存 3 个数据。此时如果我们再找 50 ，先定位到 [28-65] 这段，一下就省去了 6 段（67%）数据，再去 [35-56] 这段找，一下又省去了 2 段数据。可见我们相当于**为数据做了一个“目录”**，在提高数据检索效率的同时，多路查找树也降低了树的高度（进一步提高树的检索效率），因而 B+ 树多用于文件管理。

### B* 树

B* 树是 B+ 树的变体，**在 B+ 树的非根和非叶子节点再增加指向兄弟的指针**。一定程度上提高了空间使用率。

![bstar.png](/images/bstar.png " B* 树"){: .align-center}

- B* 树定义了 非叶子节点 关键字个数至少为 (2/3)*M ，M 指树的度（见上述）。即块的最低使用率为 2/3，而 B+ 树的块的最低使用率为 B+ 树的 1/2。

- 从第 1 个特点，可以看出 B* 树分配新节点的概率比 B+ 树要低，空间使用率更高。

## 总结

多叉树致力于解决高二叉树的效率问题，属于已有的轮子，无需设计实现，但要了解原理。

![flowChart02.png](/images/flowChart02.png "总结多叉树"){: .align-center}