---
layout: post
title: "计网 Ch5：运输层-1"
author: LJC
tags:
- network
date: 2022-10-31 13:12 +0800
toc: true
---

# 运输层 (Transport layer) - Part1

此前所介绍的 物理层，数据链路层，网络层 共同解决了将主机通过异构网络互连起来所面临的问题，**实现了主机到主机的通信**。但实际上，在计算机网络中**进行通信的真正实体是 位于通信两端主机中的进程**。

![tl01.png](/images/net/tl01.png "TL")

## 1. 运输层：为进程通信提供服务

【运输层的任务】：为应用进程的通信提供服务，即**如何运行在不同主机上的应用进程提供直接的通信服务是运输层的任务**，运输层协议又称为端到端协议，应用范围是 **进程到进程，即【端到端】**。

![tl02.png](/images/net/tl02.png "TL2")
 
注意图中的虚线，表示数据的传输方向。如图，不同的进程如何区分？ 

**运输层使用不同的端口来对应不同的应用进程**，然后通过网络层及下层来传输报文。接收方的运输层**通过不同端口**，将收到的应用层报文交付给应用层中相应的应用进程。这里的【**端口**】并不是物理意义上的实体端口，而是指用来**区分不同应用进程**的**标识符**。

> 为了简单起见，在学习运输层时，简单地认为**运输层直接为 应用进程间的逻辑通信提供服务**。


运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑，路由选择协议等），它让进程看见的就好像两个运输层实体之间有一条端到端的逻辑通信信道。根据应用需求的不同，运输层为应用层提供了两种不同的运输协议，即 **面向连接的 TCP 和无连接的 UDP** ，这两种协议就是运输层的主要内容。

### 端到端 和 点到点

**端到端 end-to-end** ：假设将数据从A传送到E，中间可能经过 **A**→B→C→D→**E**，但运输层并不知道 B/C/D 的存在。对它来说：从A传送到E，那只关注A和E（两端），只认为报文数据是从一端 A 到另一端 E 的，这就是端到端。
- 如图中蓝色的逻辑直连通道
- ![tl03.png](/images/net/tl03.png "端到端")

**点到点**：以网络层为例，它要关心从A点去往下一个点（涉及到路由选择等）

端到端和点到点的区别与联系：
- 端到端由若干的点到点实现和组成，它是建立在点到点的基础之上的。
- 直白说，**传输层及以上使用端到端**，**网络层及以下使用点到点传输**。
    - （路由器是分水岭，它最高到网络层）
- 从 点到点 到 端到端，也是封装的体现；

------

## 2. 运输层端口号，复用与分用

### **端口号**

> 运输层为进程通信提供服务，不同进程用不同端口号区分。

在 PC 上，不同进程用 **进程标识符 PID** 来区分。但因特网上的主机运行的不同操作系统（Win，Mac，Linux，Unix）使用的**进程标识符格式也不同**。那么，为了让进程之间通信，就要**统一对 TCP/IP 体系的应用进程 作标识**。

TCP/IP 体系的运输层使用 **端口号** 来区分 应用层的不同应用进程。
- **端口号（16 bit）**：取值范围 **0~65535** ，【3种】

    - 熟知端口号：0~1023，指派给 TCP/IP 体系中最重要的一些应用协议，如 FTP(21/20)，HTTP(80)，DNS(53)；

    - 登记端口号：1024~49151，为没有熟知端口号的应用程序使用。使用必须在互联网协会登记，防止重复。如 Microsoft RDP 远程桌面使用 3389 ，MySQL (3306) 。
    
    - 短暂端口号：49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号，通信结束后该端口号可供其他客户进程以后使用。

- 注意，**端口号只具有本地意义**，即端口号只是为了（在TCP/IP体系下）**标识本计算机应用层中的各进程**，在因特网中，**不同计算机中的相同端口号是没有联系的**。

-----------

### 发送方的复用和接收方的分用

如下图：

- 对发送方而言：
    - 运输层：不同端口号的应用进程 **复用（都用）** **UDP 和 TCP 协议**封装，再交给网络层；
    - ↓
    - 网络层：UDP用户数据报 和 TCP报文 **复用（都用）** IP 协议 封装成 IP 数据报；
        - IP 数据报头中 [协议字段](https://jeremy1lee.github.io/2022/10/29/network-ch4-2/#%E4%B8%89%E5%9B%9B%E4%BA%94%E8%A1%8C) 表明该数据载荷是运输层用的哪个协议数据单元（6/17）；

- ![tl04.png](/images/net/tl04.png "发送方的复用和接收方的分用")

- 对接收方而言：
    - 网络层： IP 数据报 **分用（分别用）** IP 协议 上交给 UDP 和 TCP ；
        - 依然由 IP 数据报头中 协议字段表明该数据载荷是运输层用的哪个协议数据单元（6/17）区分；
    - ↓
    - 运输层：UDP和TCP **分用（分别用）** 不同端口号，把数据交付给上层相应的应用进程；

**应用层常用协议** 使用的 运输层**端口号**：
- ![tl05.png](/images/net/tl05.png "端口号")

举例如图：一个以太网中有 DNS 服务器，web服务器，PC，交换机互连。

![tl06.png](/images/net/tl06.png "场景")

- 在 PC 中使用浏览器访问web服务器中的内容，输入域名URL后，**DNS 客户端进程**会发送一个 DNS 查询请求报文
- 该报文是 进程到进程，属于运输层，需要使用 UDP 协议：
    - 源端口号 为一个登记端口号，假设是 49152；
    - 目的端口 设置为 应用层DNS协议使用的运输层端口号 53；
    - ![tl07.png](/images/net/tl07.png "端口号")
- 封装在 IP 数据报中，再封装到帧中，发送给 DNS 服务器
    - 服务器拆封后，根据端口号53，交付给 DNS 服务器端进程
    - 发回一个 DNS 响应报文，这次目的地址是短暂端口号；
    - ![tl08.png](/images/net/tl08.png "回文")
- 主机收到web服务器的ip地址，HTTP（端口号80）进程向web服务器发送请求报文：
    - ![tl09.png](/images/net/tl09.png "HTTP")
- web 服务器回文
    - ![tl10.png](/images/net/tl10.png "HTTP 回文")
- 主机进程解析 HTTP 相应报文，在浏览器中显示，看到网页内容。

---------------------

## 3. UDP 和 TCP 的对比

TCP/IP 协议体系中运输层的两个重要协议，使用频率仅次于 IP 协议。应用层的某些协议用运输层的UDP提供的服务，另一些用到TCP提供的服务。

**用户数据报协议 UDP** (User Datagram Protocol) 和 **传输控制协议 TCP** (Transmission Control Protocol)

### -1 发送数据：UDP 无连接，TCP 面向连接

- UDP 可以随时发送数据，而 TCP 数据传输之前必须经过**三报文握手**建立 TCP 连接，然后再数据传输，完成传输后，必须**四报文挥手**来释放 TCP 连接。
    - 所以才叫 **UDP 无连接， TCP 面向连接**。
    - ![tl11.png](/images/net/tl11.png "UDP 和 TCP")

- UDP 支持单播，组播，广播（一对一，一对多，一对全），**TCP 仅支持 单播**（一对一）。

### -2 处理应用报文：UDP 面向应用报文，TCP 面向字节流

- UDP 直接给应用层报文加一个 UDP 首部，成为 UDP 用户数据报，然后发送；
    - 接收方去掉UDP 首部，将应用层报文交付给应用进程；
    - UDP 既不合并，也不拆分，保留报文的边界；
- **UDP 是面向应用报文的**
    - ![tl12.png](/images/net/tl12.png "UDP 和 TCP -2")

- TCP 把应用进程交付下来的数据块仅看成一连串的无结构字节流，TCP 并不知道这些字节流的含义，**仅编号**并**存储**在自己的发送缓存中；
    - TCP 根据发送策略，从发送缓存中提取一定数量的字节构建 TCP 报文段并发送；
    - 接收方 TCP ：
        - 一方面从接收到的 TCP 报文段中取出数据载荷，放在接收缓存中；
        - 一方面将接收缓存中的一些字节交付给应用进程；
    - TCP 并不保证 发送的数据块和接收的数据块 具有 <u>对应大小</u> 的关系
        - 例如发送方进程给了10个数据块，但接收方的 TCP 可能只用了四个数据块就把收到的字节流交付给了上层的应用进程（发送和接收方的差异）
        - 但接受方收到的字节流**必须**和发送方进程发出的字节流**完全一样**
            - 当然，接收方的应用进程必须有能力识别收到的字节流，并还原成有意义的应用数据
            - TCP 两端可以同时发送和接收（全双工）
- **TCP 是面向字节流的**，也是实现可靠传输，流量控制，拥塞控制的基础

### -3 提供服务：UDP不可靠，TCP可靠

- UDP 向上层提供无连接不可靠传输服务
    - 若误码，直接被丢弃
    - 路由器丢弃就丢弃了，发送方也不会重发
- UDP 特性使其 适用于 IP 电话，视频会议，直播，游戏等；

- ![tl13.png](/images/net/tl13.png "UDP 和 TCP - 3")

- 尽管 IP 协议也提供无连接不可靠的服务，但只要运输层用 TCP ，就可向其上层提供面向连接的可靠传输服务。
    - 想象成 建立了一个基于 TCP 连接的**可靠**信道进行传输（图中绿色信道），不会出现差错。（回想一下 [停止等待，回退N帧，选择重传](https://jeremy1lee.github.io/2022/10/21/network-ch3-1/#4-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8F%8A%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95)）
- TCP 适用于**文件传输**。

> 当时提到，停止等待，回退N帧，选择重传 这三种可靠传输实现机制的原理不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中。运输层就是其一。

### -4 报文段首部：

- UDP 报文首部只有四个字段，每个字段长两个字节，只是添加了用于区分应用进程的端口。

- ![tl14.png](/images/net/tl14.png "UDP 和 TCP - 4")

- TCP 报文段由首部和数据载荷两部分构成：
    - TCP 首部较复杂，最小 20 字节，最大 60 字节；
        - 因为要实现可靠传输，流量控制，拥塞控制等服务，所以复杂，字段多，长度长；
        - UDP 要实现一些功能也可以自己定义报文，也会复杂

--------------------

## 4. TCP 的流量控制 


