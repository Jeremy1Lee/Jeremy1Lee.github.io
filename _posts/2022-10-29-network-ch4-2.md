---
layout: post
title: "计网 Ch4：网络层-2"
author: LJC
tags:
- network
date: 2022-10-29 20:21 +0800
toc: true
---

# 网络层 (Network layer) - Part2

## 6. 路由选择协议 (Routing Protocol)

继续讨论该选择哪个路由的问题，**路由选择协议**可分为：
- 静态路由选择：采用人工配置的方式给路由器添加 [网络路由，默认路由，特定主机路由，黑洞路由](https://jeremy1lee.github.io/2022/10/27/network-ch4-1/#5-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E4%BA%BA%E5%B7%A5%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E8%B7%AF%E7%94%B1%E9%97%AE%E9%A2%98) 等路由信息；

    - 简单，开销小，但**不能适应网络变化（流量，拓扑）**
    - **小规模网络**采用

- 动态路由选择：路由器通过路由选择协议 **自动获取路由信息**；
    
    - 复杂，开销大
    - 能**较好地适应网络状态变化**
    - 适用于**大规模网络**

无论什么协议，**路由选择协议都是在路由器上运行的**。

## - 6.1 路由选择协议概述

因特网作为最大的互联网，其采用的路由选择协议具有 **分布式，自适应，分层次**的特点。
- 自适应：动态路由选择，较好地适应网络状态变化；
- 分布式：**各路由器**信息交互，**共同完成** <u>路由信息获取和更新</u>；
- 分层次：整个因特网分成较小的**自治系统** AS (Autonomous System)，例如一个 ISP 。并在 AS 内外采用不同的路由选择协议分别进行路由选择。

既然是是分层次，那么对于两个自治系统：
- 自治系统**之间**的路由选择：**域间路由选择**

    - 外部网关协议 EGP ，或称 外部路由协议 ERP （指一类协议，不是具体一个协议）
        - 内部用什么 EGP 和其他系统用什么无关

- 自治系统**内部**的路由选择：**域内路由选择**：
    - 内部网关协 IGP ，或称 内部路由协议 IRP （指一类协议，不是具体一个协议）

![rp01.png](/images/net/rp01.png "AS")

常见的路由选择协议：

- **IGP** /内部：
    - RIP（最早）【距离向量】
    - IGRP（被EIGRP取代）【距离向量】
    - EIGRP 【混合】
    - OSPF（广泛使用在各种网络）【链路状态】
    - IS-IS（ISP骨干网上用的）【链路状态】
- EGP
    - BGP

![rp02.png](/images/net/rp02.png "AS")

### 路由器的基本结构

路由器是一种**具有多个输入端口和多个输出端口的专用计算机**。其任务是转发分组。结构按功能可划分为两大部分：

![router02.png](/images/net/router02.png "路由器")

1. 路由选择：核心是路由选择处理机，它根据所使用的路由选择协议周期性**与其他路由器**进行**路由信息交互**，来**更新路由表**，此外还要周期性给其他路由器发送自己所知道的路由信息。（这要通过下面的结构实现）
2. 分组转发：三部分：交换结构，一组输入，一组输出
- 比特流→帧→分组（网络层），看【分组类型】是什么，如果是：
    - 待转发的**数据分组**：根据目的地址查表转发，找不到就丢弃；否则，按匹配条目指示的端口转发，并更新一些字段的值（比如生存字段 -1）；
    - 路由器之间交换路由信息的**路由报文**：送交上面的路由选择处理机，用它更新**路由表**；
    - 注意这里 **路由表和转发表** 的差异：路由表路线最优，转发表查找最优：
        - ![router04.png](/images/net/router04.png "路由表和转发表")
- 数据链路层封装成帧→比特流→电信号发送；

3. 另外，路由器的各端口还应具有：
- **输入缓冲区**：暂存新进入路由器但来不及处理的分组；
- **输出缓冲区**：暂存处理完毕，但还来不及发送的分组；

图示如下：注意**一个端口即可输入也可输出**，图只是为了清楚理解流程。
![router03.png](/images/net/router03.png "路由器的结构")

--------------------
## - 6.2 路由信息协议 RIP 的基本工作原理

**路由信息协议 RIP** (Routing Information Protocol) 是内部网关协议 IGP 中**最先**得到广泛使用的协议之一。

- RIP 要求自治系统 AS 内的每一个路由都要维护从它自己到 AS 内其他每一个网络的距离记录，这时一组距离，称为 **距离向量 D-V (DIstance-Vector)**。
- ![rip01.png](/images/net/rip01.png "rip协议")
- RIP 使用 **跳数（Hop Count）**作为度量（Metric）来**衡量到达目的网络的距离**。
    - 路由器**到直连网络**的距离定义为 **1**；
    - 路由器**到非直连网络**的距离定义为 **所经过的路由器数 + 1**（两段：到直连，直连）；
    - 允许一条路径最多包含 15 个路由器，即 **距离为16时相当于不可达**；
    - **RIP 因此只适用于小型互联网**

（一） RIP 认为的好与坏：

1. RIP 认为 **好的路由就是距离短的路由**，也就是**通过路由器数量最少的路由**；
    - ![rip02.png](/images/net/rip02.png "rip协议认为好的路由")

2. 当到达同一目的网络有**多条距离相等的路由**时，RIP 可以进行**等价负载均衡**，即将通信量均衡地分布到多条等价的路由上
    - ![rip03.png](/images/net/rip03.png "rip协议")

3. RIP 包含以下三个要点：
    - **和谁交换信息？**——只和**相邻路由器**交换信息，如下图的 R1 和 R2 中间没有其他路由器，是相邻的；R1 和 R3 之间还存在其他路由器，不是相邻的。
        - ![rip04.png](/images/net/rip04.png "rip协议")

    - **交换什么信息？**——路由器自己的**路由表**；

    - **何时交换信息？**——**周期性交换**，例如每 30s 发一次rip更新报文

----------------

### RIP 的工作过程

（二） RIP 的基本工作过程

1. 路由器**刚开始工作时，只知道自己到直连网络的距离为1**，如图的条目都是到各自直连网的信息，距离都是1（实现方式可以是广播/组播）；
    - ![rip05.png](/images/net/rip05.png "rip开始")
2. 每个路由器**只和相邻路由器周期性地交换并更新路由信息**，如 R1/R2，R1/R3，R2/R3
3. 若干次交换和更新后，**每个路由器都知道到达本 AS 内各网络的最短距离和下一跳地址**，称为收敛。（可理解为一种完成初始化的操作）
    - ![rip06.png](/images/net/rip06.png "rip收敛")

（三） RIP 的路由条目更新规则

- C D 互为相邻路由器，它们周期性交换并更新路由信息。当C 该发送时，把自己的路由表信息封装到 RIP 更新报文发给 D 。（可以认为C把自己的路由表发给了D）
- D收到后对其改造
    - 将到达 C 的表的下一跳都改成 C ；
    - 距离都加 1 ；
    - 因为：C 告知 D它可以到达这些网络，途径是经过C，因此到这些网络的下一跳是C，而距离是C到它们的距离+1；
    - ![rip07.png](/images/net/rip07.png "如何改造")
- D 根据改造好的路由表更新自己先前的路由表，更新原则有：
    - ① 到达原有网络，且有**相同下一跳**的，有最新的消息，应该更新；【说明网络拓扑变化了】，如原来 D从C再到E 的距离是5，新消息表明 C到E 变为1，那么最新 D从C到E 的距离更新成 2；
    - ② 发现新的网络，添加；
    - ③ 到达目的网络，且**不同的**下一跳，新路由路线更优，更新；
    - ④ 到达目的网络，且**不同的**下一跳，新老路由路线相等，进行等价负载均衡；
    - 【不更新】：到达目的网络，**不同的**下一跳，新路由路线更差；
    - 【注意】：**大于15不可达**！
    - ![rip08.png](/images/net/rip08.png "各种情况")

### RIP 存在的问题

（四）RIP 存在 **坏消息传播得慢/路由环路/距离无穷计数**问题

出现了故障，R1把到达 N1 的距离改成16，表示 N1 不再可达，等RIP更新周期到时后发送该信息给R2。但此时R2的表中关于N1的信息仍然是此前获取到的，如图。

![rip10.png](/images/net/rip10.png "坏消息")

假设： R2 先到更新时间，即R2的信息先到达 R1，R1的坏消息后到达R2。

![rip09.png](/images/net/rip09.png "坏消息")

此时R1会被这条信息误导【旧的N1=16被覆盖掉了】，认为可以通过 R2 到达 N1 ，距离为3 。并等待发给 R2 。 R2 收到 R1 的"谣言"后，也被误导，认为可以通过 R1 到达 N1，距离为 4 ，并准备发给 R1.......以此循环往复，直到二者的路由表中到 N1 的距离**都达到 16** 时才收敛，

![rip11.png](/images/net/rip11.png "坏消息")

在此过程中，R1/R2 出现了路由环路，时间长达数分钟，这是**距离向量算法的一个固有问题**。可以采取多种措施**减少**出现该问题的概率或减小该问题带来的危害。但是并**不能彻底避免**路由环路问题，这是**距离向量算法**的本质导致的。
- 限制最大距离为 15
- 路由表一有变化，就**立即发送**更新报文（即 **触发更新**），而不仅是周期性发送；
- 让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口反方向发送（即 **水平分割**）

注意，这里只介绍了 RIP 最基本的工作原理，并不是全部细节，如 RIP 有关报文的格式，定时时长等。基于 IPv4 的 RIP 有两个版本，还有基于 IPv6 的 RIPng 等。

-------------
## - 6.3 开放最短路径优先 OSPF （基于 Dijkstra 算法）

**开放最短路径优先 OSPF**(Open Shortest Path First) 是为客服 RIP 协议的缺点在1989年开发的；
- 开放： 表示 OSPF 是公开发表的；
- 最短路径优先： 是因为使用了 迪杰斯特拉提出的**最短路径**算法算法 SPF

OSPF 采用最短路径优先算法计算路由，从算法上保证了**不会产生路由环路**。同时**不限制网络规模，更新效率高，收敛速度快**。

### 链路状态的获取，存储

（1）链路状态的获取，存储

注意，OSPF 是**基于链路状态**的，不像 RIP 是基于距离向量的；
- **链路状态**是指：1）本路由器都**和哪些路由器相邻**，2）相应 **链路的代价 (cost)**；
    - 代价 cost 用来表示费用，距离，时延，带宽等，都由网络管理人员来决定，例如下图：
        - ![ospf01.png](/images/net/ospf01.png "代价")

- OSPF 相邻路由器之间交互**问候（Hello）分组**，建立和维护**邻居关系**，如下图：
    - ![ospf01-1.png](/images/net/ospf01-1.png "场景图")

    - **问候（Hello）分组** <u>封装在 IP 数据报中</u>，发往组播地址 224.0.0.5 ；
        - ![ospf02.png](/images/net/ospf02.png "数据报结构")
        - Hello 分组 发送周期为 10秒 ；

    - 若 40s 未收到邻居的 Hello 分组，则认为该邻居路由器不可达。为此每个路由器都建立一个**邻居表**，记录其各邻居路由器的相关信息；
        - ![ospf03.png](/images/net/ospf03.png "邻居表")

### 向外通告链路状态，并计算最短路径

（2）向外通告链路状态

- 使用 OSPF 的每个路由器都会产生 **链路状态通告 LSA** (Link State Advertisement)。LSA 中包含以下内容：
    - **直连网络** 的链路状态信息
    - **相邻路由器** 的链路状态信息
        - ![ospf04.png](/images/net/ospf04.png "链路状态通告")
    
-  LSA 被封装在 **链路状态更新分组 LSU** 中，采用**洪泛法**发送。收到链路状态更新分组的路由器将从自己其他所有接口转发该分组（也是洪泛转发）
    - 这样每个路由器发的链路状态都能传给其他所有路由器。

- 使用 OSPF 的每个路由器都有一个**链路状态数据库 LSDB**，用于存储 LSA 。

- 通过各路由器洪泛发送封装有自己 LSA 的 LSU 分组，各路由器的 LSDB 将达到一致，下图看 LSA/LSU/LSDB 的关系：
    - ![ospf05.png](/images/net/ospf05.png "LSxx 的关系")

**（3）应用链路状态，计算最短路径**

使用 OSPF 的各路由器 **基于 LSDB 进行最短路径优先 SPF 计算**，构建出各自到达其他路由器的最短路径，即构建各自的路由表。如图，**边的数值表示代价（权值）**。

![ospf06.png](/images/net/ospf06.png "OSPF的场景")

通过洪泛发送，所有路由器都会统一得到**相同的链路状态数据库**，得到带权有向图，应用 [迪杰斯特拉算法](https://jeremy1lee.github.io/2022/10/15/ten-algorithms-2/#%E5%85%AB%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89-dijkstra-%E7%AE%97%E6%B3%95---%E6%9F%90%E4%B8%80%E8%B5%B7%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84) ，即**最短路径优先算法**，得出【以本路由器为起点，其他各路由器为终点】的最短路径。 

![ospf07.png](/images/net/ospf07.png "OSPF的场景")

### 增效与改进机制

**（4）OSPF 的分组细节和应用分组的工作过程：**

- OSPF 有以下五种分组类型：

    - ![ospf08.png](/images/net/ospf08.png "OSPF的分组")

- 以两个相邻路由器为例，OSPF的工作过程如下：

    - ![ospf09.png](/images/net/ospf09.png "OSPF的工作过程")

**（5）OSPF 减少组播，提高效率的机制**

看这种情况，路由器两两为邻居，每次要发n-1个Hello分组和状态更新分组。

![ospf10.png](/images/net/ospf10.png "OSPF的特殊情况")

为了减少发送分组数，OSPF 采用 **选举指定路由器 DR** (Designated Router) 和 **备用指定路由器 BDR** (Backup Designated Router) ，如下图左：

![ospf11.png](/images/net/ospf11.png "DR")

现在，所有的 **非 DR / 非 BDR** 只和 **DR/BDR** 建立关系，如上图右，邻居关系数量降低。
- 非 DR / 非 BDR 的路由器 （没title的）之间不能直接交换关系，必须通过 DR/BDR 进行交换；
- DR 出问题由 BDR 顶替；
- 选举 DR/BDR 也不复杂，只要交换一些参数如优先级，ID，接口IP等，根据选举规则选【与 STP 协议选举根交换机类似】

**（6）在大规模网络应用 OSPF 的机制**

同样是为了减少洪泛，划分子区域，设定如下：

![ospf12.png](/images/net/ospf12.png "大规模网络应用 OSPF")

OSPF 把一个 AS 再分成 **区域 Area**，用区域标识符表示（32bit 十进制点分，类似Ipv4），主干区域必须是【0.0.0.0】，**目的是减少每个区域内部交换路由信息的洪泛通信量**。

![ospf13.png](/images/net/ospf13.png "很大规模网络应用 OSPF的机制")

----------------

## - 6.4 边界网关协议 BGP （复杂，简单讨论）

不同 自治系统内，度量路由的代价（费用，带宽，距离等）可能不同，代价不能作为自治系统之间的路由选择度量。（无向图中 边的权值度量不一）也就无法选出最佳路由。

![bgp01.png](/images/net/bgp01.png "不同自治系统")

BGP 力求寻找一条能够达到目的网络，且比较好的路由（不能兜圈），而非要寻找一条最佳路由。

- 配置 BGP 时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的 **BGP 发言人**（往往是边界路由器）；

![bgp02.png](/images/net/bgp02.png "BGP")

- 不同自治系统的 BGP发言人 要交换路由信息，首先建立 **TCP 连接**，端口号为 179；
    - 在此 TCP 连接上交换 BGP 报文以**建立 BGP 会话**；
    - 利用 BGP 会话**交换路由信息**（增加新路由，撤销过时路由，报错...）
    - 用 TCP 连接交换路由信息的两个 BGP发言人 彼此称为对方的 **邻站 (neighbor)** 或 **对等站 (peer)** 
- BGP发言人 除了运行 BGP，还要运行自己所在自治系统使用的内部网关协议 IGP ，如 RIP 和 OSPF；

**基本工作原理**

- BGP发言人交换可达性的信息（即到达某个网络要经过一系列AS）；

- 交换可达性信息后，BGP 发言人根据所采用策略从收到的路由信息中**找出到达各自治系统的较好的路由**，即构造出**树形结构，不存在回路的自治系统连通图**。

    - ![bgp03.png](/images/net/bgp03.png "BGP")

- BGP 适用于多级结构的因特网：
    - ![bgp04.png](/images/net/bgp04.png "BGP如何用于多级结构")

- BGP-4 的四种报文：【BGP的报文被封装在 TCP 报文段中进行传输】
    - ![bgp05.png](/images/net/bgp05.png "BGP四种报文")

刚运行BGP时交换整个BGP路由表，以后只需要更新有变化的部分，节省带宽和网络开销。

最后，封装 各路由选择协议报文的协议 如下图：

![router05.png](/images/net/router05.png "路由选择协议的封装")

-------------------

## 7. IPv4 数据报的首部（头）格式

> 下面将 IPv4 数据报简称为 IP 数据报

IPv4 数据报的**首部格式和内容是实现 IP 协议主要功能的基础**，可分为两大部分：

- **固定部分**（20字节）：每个 IP 数据报首部都必须有的部分；

- **可变部分**（最大40字节）：可选字段，增加 IP 数据报的功能；

![ipd01.png](/images/net/ipd01.png "ip数据报的格式")

- **32 bit** 为一个单位，即图中**一行**是32bit。

- 图中每个**小格**称为 **字段**，或者 **域**：字段或字段的组合表达 IP 协议的相关功能。

接下来详细介绍每一行中的各字段：

### IP 数据报第一行

- ① **第一行**：

    - **版本**（4 bit）：表示 IP 协议的版本，通信双方的版本必须一致，广泛为4，即 IPv4 ；

    - **首部长度**（4 bit）：表示 IP 数据报首部的长度，该字段取值以 **4 字节为单位**，即×4。
        - 最小十进制取值为 5 ，表示该 数据报首部只有 20 字节，即只有固定部分；
        - 最大为 15 ，表示该IP数据报首部有 60 字节，即 20 字节固定部分 和 40字节满的可变部分；
    
    - **可选字段**（1~40 bit）：支持排错，测量及安全等措施；
        - 增加的长度增加了开销，实际上可选字段很少使用；

    - **填充字段**：确保整个首部长度为 4 字节的整数倍，全填充 0 即可；

    - **区分服务**（8 bit）：用来获得更好的服务，该字段的不同数值可提供不同等级的服务质量
        - 只在使用区分服务时才用到该字段，一般都用不上；

    - **总长度**（16 bit）：表示 IP 数据报的总长度【首部 + 数据载荷】；
        - 最大为10进制 65535，以**1字节为单位**，但很少传这么长的数据报；
        - **首部长度字段【4 字节为单位】** 与 **总长度字段【1 字节为单位】**  的区别与联系：
            - ![ipd02.png](/images/net/ipd02.png "首部长度与总长度")
            --------------------------------------------------------

### IP 数据报第二行

- ② **第二行**：

    - **第二行的【标识，标志，片偏移】** 共同用于 **IP 数据报分片**：
        - 网际层封装的 IP 数据报将在链路层封装成 帧，而链路层中规定了帧的数据载荷的最大长度（**最大传输单元 MTU**）。如果某个 **IP 数据报的总长度超过了 MTU** ，将无法封装成帧；
            - ![ipd03.png](/images/net/ipd03.png "IP 数据报分片")
        - 需要**将原 IP 数据报分片**为更小的 IP 数据报，然后将各分片封装成帧，就用到了这三个字段：

    - **标识**（16 bit）：属于同一个数据报的各分片数据报 标识相同。【识别数据报的各片段】；
        - IP 软件维持一个计数器，每产生一个数据报，计数器值加1，并将此值赋给标识字段；

    - **标志**（3 bit）：各bit含义如下：
        - DF 位：是否允许分片 【1 不允许，0 允许】；
        - MF 位：是否还有分片 【1 表示本片后面还要分片，0 表示这是最后一个分片】；
        - 保留位：必须设置为 0 ；

    - **片偏移**（13 bit）：指出分片数据报的数据载荷部分偏移其在原数据报的位置有多远；
        - 片偏移以 **8 个字节为单位**，且必须为**整数**；

    - 分片过程举例如下图：
        - 首部20字节，数据载荷3800字节，一共3820字节，但以太网最多1500字节
        - ![ipd04.png](/images/net/ipd04.png "IP 数据报分片过程")
        - 所以，将数据载荷分成三部分，每部分1400字节，并且安上**新的首部**；
            - 得到新的三个分片字段信息如下：
            - ![ipd05.png](/images/net/ipd05.png "分片的字段信息")
        - 此时假设分片2 还要再分片：
            - ![ipd06.png](/images/net/ipd06.png "再分片")
            ---------------------------------------------------

### 三/四/五行

- ③ **第三行**：

    - **生存时间 TTL**（8 bit）：防止 IP 数据报在网络中永久兜圈；
        - 最初以 **秒** 为单位，最大生存周期为 255 秒；路由器转发 IP 数据报时，将 IP 数据报首部中的该字段值 减去 IP 数据报在本路由器上所耗费的时间，若不为 0 就转发，否则为 0 就丢弃。

        - 现在 **跳数** 为单位，路由器转发 IP 数据报时，将 IP 数据报首部的该字段 -1 ，若不为 0 转发，为 0 丢弃。
        - 如图，N1发往N2，如果没有生存时间将一直兜圈；
            - ![ipd07.png](/images/net/ipd07.png "生存时间的作用")
    
    - **协议**（8 bit）：指明 IPv4 数据报的 **数据部分** 是 何种协议数据单元。
        - 如图，为1表明是 ICMP 报文（ICMP协议封装的单元），为 6 表明是 TCP 协议封装的协议数据单元 .....
        - ![ipd08.png](/images/net/ipd08.png "协议")
    
    - **首部检验和**（16 bit）：检测首部在传输过程中是否出现差错。检错码比 CRC 检错码简单，称为 因特网检验和。
        -  IP 数据报每经过一个路由器，路由器都要重新计算 首部检验和 ，因为某些字段（生存时间，标志，片偏移等）可能有变；
        - 网际层本身不提供可靠传输，而且检错耗时，所以 **IPv6 不再计算首部检验和**。
        -------------------------------------------------------

- ④ **第四/五行**：

    - **源 IP 地址** 和 **目的 IP 地址**（各 32 bit）：发送该数据报的源主机 IP 地址和接收该数据报的目的主机的 IP 地址；

    -------------------------------------------------------

最后，封装好的 IP 数据报送到链路层继续封装成帧，它们的关系是这样的：

![ipd09.png](/images/net/ipd09.png "ip与帧")

----------------------------

## 8. 网际控制报文协议 ICMP（IP 报文的增效机制）

【目的】：**为了更有效地转发 IP 数据报和提高交付成功的机会**，网际层使用了 **网际控制报文协议 ICMP**(Internet Control Message Protocol)。

主机/路由器 使用 ICMP 来发送 **差错报告报文和询问报文**。 ICMP 报文 封装在 IP 数据报中发送；

### ICMP 差错报告报文

第一类 ICMP【差错报告报文】共有以下五种小类型：

- 终点不可达
    - ![icmp01.png](/images/net/icmp01.png "icmp01")

- 源点抑制
    - ![icmp02.png](/images/net/icmp02.png "icmp02")

- 时间超过
    - ![icmp03.png](/images/net/icmp03.png "icmp03")

- 参数问题
    - ![icmp04.png](/images/net/icmp04.png "icmp04")

- 改变路由（重定向）
    - ![icmp05.png](/images/net/icmp05.png "icmp05")

【注意】以下情况**不应发送 ICMP 差错报告报文**：
![icmp06.png](/images/net/icmp06.png "不应发送 icmp")

### ICMP 询问报文

第二类 ICMP【询问报文】有以下两种类型：

- **回送请求和回答**：

    - ![icmp07-1.png](/images/net/icmp07-1.png "回送请求和回答60")

- **时间戳请求和回答**：

    - ![icmp08-1.png](/images/net/icmp08-1.png "时间戳请求和回答60")

### ICMP 的典型应用：PING 和 跟踪路由

（一）分组网间探测 PING(Packet InterNet Groper)

PING 用来测试主机/路由器之间的连通性，其应用层直接使用网际层的 ICMP （没有通过运输层的 TCP 或 UDP），使用 ICMP 回送请求和回答。

测试一下：![ping01.png](/images/net/ping01.png "PING-test")

（二）跟踪路由 traceroute

用来测试 IP 数据报从源主机到达目的主机要经过哪些路由器。Windows 下是 tracert 命令，应用层直接网际层的 ICMP ，使用 ICMP 回送请求和回答报文，以及差错报告报文。

测试一下：![trrt01.png](/images/net/trrt01.png "tr-test")

如何实现的呢？基于 TTL ，到达路由器后变成0，路由器就要还给本主机一个差错报告报文，就能提取到路由器地址。接下来 TTL =2 ，=3，以此类推。只有目的主机能解析该报文，发现是一个回送请求报文，就回答，我们就得到了目的地址。

![trrt02.png](/images/net/trrt02.png "trrt-2")

![trrt03.png](/images/net/trrt03.png "trrt-3")

-------------------

## 9. 虚拟专用网 VPN 与网络地址转换 NAT

### 虚拟专用网 VPN

![vpn01.png](/images/net/vpn01.png "vpn01")

场景：一个公司的两个部门局域网通信，一种方法是租用ISP的通信线路，但租金高。

VPN (Virtual Private Network)：**利用公用的因特网**作为本机构各专用网之间的通信载体，这样的专用网又称虚拟专用网。

![vpn02.png](/images/net/vpn02.png "vpn02")

虚拟专用网中的各主机所分配的地址应该是本机构**可自由分配的专用地址（私有地址）**，而不是需要申请的/ 在因特网上使用的公有地址。

【注意】：**私有地址**只能用于一个机构的内部通信，不能用于和因特网上的主机通信。即只能用作本地地址，而不能用作全球地址。因特网中的所有路由器对**目的地址是私有地址的 IP 数据报一律不转发**。

![privateip01.png](/images/net/privateip01.png "私有专用地址"){: .align-center}

为了使用因特网，A/B各自需要一个路由器，具有合法的全球 IP 地址，这样专用网才能利用公有的因特网进行通信。（路由器的两个端口各属于不同网络，有不同的网络地址，一个连私有网，一个连公有的因特网）

![vpn03.png](/images/net/vpn03.png "vpn路由器")

A 网络中的主机给 B 发数据报，如图，R1发现该目的网络 <u>必须通过因特网到达</u> ：

![vpn04.png](/images/net/vpn04.png "vpn4")

- R1 将其**加密**，确保 IP 数据报的安全
- 然后重新添加上首部，封装成在因特网上发送的外部数据报，IP 数据报头中：
    - 源地址：R1的全球地址
    - 目的地址：R2的全球地址
- R2 收到后去掉首部，并解密，恢复成原来的内部 IP 数据报
- 再从首部提取出源地址（A 中主机）和目的地址（B 中主机），并发给相应主机

![vpn05.png](/images/net/vpn05.png "vpn")

虽然传输通过了因特网，但效果上和本机构的专用网上传送一样。数据报在因特网中势必要经过多个网络和路由器，但逻辑上看R1/R2之间好像是一条直通的点对点链路，因此也称为 **IP 隧道技术**。

- 同一机构内不同部门的内部网络所构成的虚拟专用网 VPN 又称为 **内联网 VPN**。
- 有时一个机构的 VPN 需要有某些外部机构（合作伙伴等）参与，这样的称为 **外联网 VPN**。
- 人在外地的员工需要访问公司内部的专用网络时，只要在任何地点接入互联网，并在 PC 上运行 VPN 软件，在 PC 和公司的主机之间建立 VPN 隧道，即可访问专用网络中的资源，这样称为 **远程接入 VPN**。【eg. 远程接入校园网】

### 网络地址转换 NAT/NAPT：缓解Ipv4短缺

网络地址转换NAT (Network Address Translation) ：缓解 IPv4 地址空间即将耗尽的问题。NAT 使大量**使用内部专用地址的专用网络用户 共享少量外部全球地址 来访问因特网上的主机和资源**。即：以牺牲独立ip的方式来解决ip不足的问题。

![nat01.png](/images/net/nat01.png "NAT的场景")

需要在路由器上安装 NAT 软件，成为 NAT 路由器，它至少有一个有效的外部全球 IP 地址。这样所有使用私有地址的主机在和外界通信时，都在 NAT 路由器上**将其私有地址转换成全球 IP 地址**。

![nat02.png](/images/net/nat02.png "NAT发送")

- NAT 路由器从自己的全球 IP 地址池中分配一个临时的**全球 IP 地址**，并覆盖 IP 数据报上的**私有地址**；
- 在 NAT 转换表记录私有地址和临时全球地址的对应关系；
- 转发
- 收到回信后，查 NAT 转换表

![nat03.png](/images/net/nat03.png "NAT回信")

存在一个问题：**NAT 路由器只有 N 个全球 IP 地址，那么最多只有 N 个内网主机能同时和因特网上的主机通信。**

由于绝大多数网络应用都是用运输层协议 TCP 或 UDP 来传送数据，因此可以利用运输层的端口号和 IP 地址一起进行转换；这样，**用一个全球 IP 地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信**。这种**将端口号和 IP 地址一起转换**的技术叫做 **网络地址与端口号转换 NAPT**(Network Address and Port Translation)

![napt01.png](/images/net/napt01.png "NAPT")

显然，第一次通信不能由外网主机发起，因为此时 NAPT 中没有记录。
- 所以**使用私有地址的主机不能直接充当因特网服务器**；
- 对于一些 P2P 网络应用，需要外网主机主动与内网主机进行通信，在通过时会遇到问题，需要网络应用自己使用特殊的 NAT 穿越技术来解决；
- NAT 也为内网主机提供了一定安全防护；

------------------