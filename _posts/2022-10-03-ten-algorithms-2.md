---
layout: post
title: "常用十种算法（二）"
author: LJC
tags:
- algorithm
- java
date: 2022-10-15 21:10 +0800
toc: true
---
将数据结构使用到实际场景，解决一个问题，重点在于算法。（2）
{: .message }

## 五、普里姆 (Prim) 算法

应用场景：修路问题-最小生成树

有 7 个村庄 (A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通，各个 **村庄的距离用边线表示(权)**，比如 A – B 距离 5 公里。如何修路保证各个村庄都能连通，并且**修建公路 总里程最短**?

思路：只满足连通的话，将 10 个点全连上就行了，但总的里程数肯定不是最小。满足连通，又保证总里程最短的思路：尽可能少修路，如果不得不修，也要修短的路，保证总里程数最少。

![mst01.png](/images/mst01.png "MST"){: .align-center}

### 最小生成树：由图到树

修路问题的本质/建模，就是最小生成树问题。最小生成树 (Minimum Cost Spanning Tree)，简称 **MST**。给定一个**带权的无向连通图**，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树 ，它有如下特点：

-  N 个顶点，一定有 N - 1 条边（如右图考虑了一种最最简陋的连接方式）

- 包含全部顶点（所有节点都可达）

- 树的 N-1 条边都在图中

求最小生成树的算法主要是 **普里姆算法** 和 **克鲁斯卡尔算法**。既然是由图到的树，而且图（多对多）更符合现实，这表明和其他树结构比，其应用范围更广。

### 普利姆 (Prim) 算法

普利姆（Prim）算法求最小生成树，也就是：在包含 n 个顶点的连通图中，找出只有 (n-1) 条边包含所有 n 个顶点的连通子图，也就是所谓的**极小连通子图**。

1. 设：
- G=(V,E) 是连通网Graph；
- T=(U,D) 是最小生成树Tree；
- V、U 是顶点集合；
- E、D 是边的集合；

2. 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 <mark>visited[u]=1</mark> ，表示已经访问过。

3. 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合U中，将边（ui,vj）加入集合 D 中，标记 <mark>visited[vj]=1</mark>。

4. 重复 **2**，直到 U 与 V 相等，即所有顶点都访问一遍（被标记过），此时 D 中有 n-1 条边，结束。

图解如下：

![prim01.png](/images/prim01.png "Prim Algorithm"){: .align-center}

代码实现：不连通的顶点用一个很大的数表示（这里是10000）。用到的数据结构：visited[ ] 表示是否访问过，把顶点分成两个集合，对 int[ ][ ] weight 作条件判断：只有起点 i 未访问且终点 j 访问过，才考虑这个边（图中黑色加粗的边），每次更新且重置的 minWeight 找到最短边，并把终点 j 标记为已访问。核心代码如下，很好理解：

{% highlight js %}
// 1. 当前节点标记为已访问
vertexVisited[startVertex] = 1;

        // 2. 直到生成 n-1 个边停止
        for (int k = 1; k < graph.verx; k++) {
            // 对目前每个节点，找它们连着的最短节点
            for (int i =0;i<graph.verx ;i++){
                for (int j = 0;j<graph.verx;j++){
                    // 起点i是访问过的节点，终点j是没访问过的节点，条件是最短，初始是10000，第一次也照顾到了
                    if (vertexVisited[i] == 1 && vertexVisited[j] ==0 && graph.weight[i][j] < minWeight){
                        minWeight = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            System.out.println("第 "+k+" 轮找到的边：由 "+graph.data[h1]+" 到 "+graph.data[h2]+" ，权值为"+minWeight);
            vertexVisited[h2] = 1;
            sumWeight += minWeight;
            minWeight = 10000; // 重置minWeight
        }
{% endhighlight %}

## 六、克鲁斯卡尔 (Kruskal) 算法

应用场景：公交站问题-最小生成树

某城市新增 7 个站点(A, B, C, D, E, F, G) ，现在 需要修路把 7 个站点连通，各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里 问：如何修路保证 各个站点都能连通，并且 总的修建公路总里程最短？ 模型本质和上面的问题一样，只是换了数值。

克鲁斯卡尔 (Kruskal) 算法，是用来求加权连通图的最小生成树的算法。n 个站点仍然是 n-1 条边，这没有变，Kruskal的基本思想是：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路。即：首先构造一个只含 n 个顶点的森林；然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止；

![kruskal01.png](/images/kruskal01.png "Kruskal Algorithm"){: .align-center}

对于如图所示的连通网，可以有多棵权值总和不同的生成树。显然连通方式有很多，但是哪一种权值才是最优的呢？下面是克鲁斯卡尔算法的图解步骤：以数组 R 保存最小生成树结果。

两条核心做法是：**1）对边的权值排序，2）加入森林并判断回路**。排序的话，8 种排序可以使用，如何判断回路才是难点。**判断回路的方式**：记录顶点在**最小生成树**中的终点，顶点的终点是 在最小生成树中与它连通的最大顶点。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。图解如下：

![kruskal02.png](/images/kruskal02.png "判断回路"){: .align-center}

<mark>终点</mark> ：将所有顶点按照加入顺序排列好之后；某个顶点的终点就是此时加入顺序中 与它连通的最大顶点。如左图，将三条边 E,F  C,D  D,E 加入最小生成树 R 之后，顶点 C, D, E, F 的终点都是 F 。

因此，接下来，虽然 边 <C, E> (5) 权值最小，但 C 和 E 的终点都是 F，即它们的终点相同，因此，将 <C, E> 加入最小生成树的话，会形成回路，C和F，C和D同理。这就是判断回路的方式。也就是说，**待加入边的两个顶点不能都指向同一个终点**，否则将构成回路。

### 代码实现

这部分是代码的核心：写一个方法，输入顶点 i ，返回其终点下标：

![kruskal03.png](/images/kruskal03.png "判断回路的代码实现"){: .align-center}

首先注意：**边的起点和终点指的是有向矢量的起始和箭头指向点**，而**顶点的终点指的是防止回路的那个人为定义的边结束点**。这段代码的意义就是按照图中红色箭头顺序寻找终点的过程，怎么实现的呢？在加入边后为每一个新增边的起点指派终点：如图所示：

- 【新增边的起点】的【终点】是【新增边的终点】；

- 【新增边的终点】的【终点】是【0】；

当查询时，就一直找这个点的终点，直到哪个点的终点是0了，那它就是有关联，且最新增的边的终点。查询时具体是：如果一个边还没加入结果集合，其两个顶点的终点都是 0 。所以，如果 ends[i] != 0，那么循环让<mark> i = ends[i];</mark>，由于在取边时的赋值操作，ends数组会循环到第一个ends为0的顶点，并返回此顶点。如右图，DE边加入后，如果再想加入FD，肯定要先判断D和F的终点。 D 在找终点 getends[D] 时，会循环： i = ends[ i ] ：

-  i0 = D, ends[i0] = ends[D] = E；
-  i1 = E, ends[i1] = ends[E] = F ；
-  i2 = F, ends[i2] = ends[F] = 0，退出循环，返回i2，即F；

这表明 D 的终点是 F 。整个 Kruskal 算法的流程图如下：

![flowChart06.png](/images/flowChart06.png "flowChart-Kruskal"){: .align-center}




