---
layout: post
title: "常用十种算法（二）"
author: LJC
tags:
- algorithm
- java
date: 2022-10-15 21:10 +0800
toc: true
---
将数据结构使用到实际场景，解决一个问题，重点在于算法。（2）
{: .message }

## 五、普里姆 (Prim) 算法 - 最小生成树

应用场景：修路问题-最小生成树

有 7 个村庄 (A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通，各个 **村庄的距离用边线表示(权)**，比如 A – B 距离 5 公里。如何修路保证各个村庄都能连通，并且**修建公路 总里程最短**?

思路：只满足连通的话，将 10 个点全连上就行了，但总的里程数肯定不是最小。满足连通，又保证总里程最短的思路：尽可能少修路，如果不得不修，也要修短的路，保证总里程数最少。

![mst01.png](/images/mst01.png "MST"){: .align-center}

### 最小生成树：由图到树

修路问题的本质/建模，就是最小生成树问题。最小生成树 (Minimum Cost Spanning Tree)，简称 **MST**。给定一个**带权的无向连通图**，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树 ，它有如下特点：

-  N 个顶点，一定有 N - 1 条边（如右图考虑了一种最最简陋的连接方式）

- 包含全部顶点（所有节点都可达）

- 树的 N-1 条边都在图中

求最小生成树的算法主要是 **普里姆算法** 和 **克鲁斯卡尔算法**。既然是由图到的树，而且图（多对多）更符合现实，这表明和其他树结构比，其应用范围更广。

### 普利姆 (Prim) 算法

普利姆（Prim）算法求最小生成树，也就是：在包含 n 个顶点的连通图中，找出只有 (n-1) 条边包含所有 n 个顶点的连通子图，也就是所谓的**极小连通子图**。

1. 设：
- G=(V,E) 是连通网Graph；
- T=(U,D) 是最小生成树Tree；
- V、U 是顶点集合；
- E、D 是边的集合；

2. 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 <mark>visited[u]=1</mark> ，表示已经访问过。

3. 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合U中，将边（ui,vj）加入集合 D 中，标记 <mark>visited[vj]=1</mark>。

4. 重复 **2**，直到 U 与 V 相等，即所有顶点都访问一遍（被标记过），此时 D 中有 n-1 条边，结束。

图解如下：

![prim01.png](/images/prim01.png "Prim Algorithm"){: .align-center}

代码实现：不连通的顶点用一个很大的数表示（这里是10000）。用到的数据结构：visited[ ] 表示是否访问过，把顶点分成两个集合，对 int[ ][ ] weight 作条件判断：只有起点 i 未访问且终点 j 访问过，才考虑这个边（图中黑色加粗的边），每次更新且重置的 minWeight 找到最短边，并把终点 j 标记为已访问。核心代码如下，很好理解：

{% highlight js %}
// 1. 当前节点标记为已访问
vertexVisited[startVertex] = 1;

        // 2. 直到生成 n-1 个边停止
        for (int k = 1; k < graph.verx; k++) {
            // 对目前每个节点，找它们连着的最短节点
            for (int i =0;i<graph.verx ;i++){
                for (int j = 0;j<graph.verx;j++){
                    // 起点i是访问过的节点，终点j是没访问过的节点，条件是最短，初始是10000，第一次也照顾到了
                    if (vertexVisited[i] == 1 && vertexVisited[j] ==0 && graph.weight[i][j] < minWeight){
                        minWeight = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            System.out.println("第 "+k+" 轮找到的边：由 "+graph.data[h1]+" 到 "+graph.data[h2]+" ，权值为"+minWeight);
            vertexVisited[h2] = 1;
            sumWeight += minWeight;
            minWeight = 10000; // 重置minWeight
        }
{% endhighlight %}

## 六、克鲁斯卡尔 (Kruskal) 算法 - 最小生成树

应用场景：公交站问题-最小生成树

某城市新增 7 个站点(A, B, C, D, E, F, G) ，现在 需要修路把 7 个站点连通，各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里 问：如何修路保证 各个站点都能连通，并且 总的修建公路总里程最短？ 模型本质和上面的问题一样，只是换了数值。

克鲁斯卡尔 (Kruskal) 算法，是用来求加权连通图的最小生成树的算法。n 个站点仍然是 n-1 条边，这没有变，Kruskal的基本思想是：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路。即：首先构造一个只含 n 个顶点的森林；然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止；

![kruskal01.png](/images/kruskal01.png "Kruskal Algorithm"){: .align-center}

对于如图所示的连通网，可以有多棵权值总和不同的生成树。显然连通方式有很多，但是哪一种权值才是最优的呢？下面是克鲁斯卡尔算法的图解步骤：以数组 R 保存最小生成树结果。

两条核心做法是：**1）对边的权值排序，2）加入森林并判断回路**。排序的话，8 种排序可以使用，如何判断回路才是难点。**判断回路的方式**：记录顶点在**最小生成树**中的终点，顶点的终点是 在最小生成树中与它连通的最大顶点。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。图解如下：

![kruskal02.png](/images/kruskal02.png "判断回路"){: .align-center}

<mark>终点</mark> ：将所有顶点按照加入顺序排列好之后；某个顶点的终点就是此时加入顺序中 与它连通的最大顶点。如左图，将三条边 E,F  C,D  D,E 加入最小生成树 R 之后，顶点 C, D, E, F 的终点都是 F 。

因此，接下来，虽然 边 <C, E> (5) 权值最小，但 C 和 E 的终点都是 F，即它们的终点相同，因此，将 <C, E> 加入最小生成树的话，会形成回路，C和F，C和D同理。这就是判断回路的方式。也就是说，**待加入边的两个顶点不能都指向同一个终点**，否则将构成回路。

### 代码实现

这部分是代码的核心：写一个方法，输入顶点 i ，返回其终点下标：

![kruskal03.png](/images/kruskal03.png "判断回路的代码实现"){: .align-center}

首先注意：**边的起点和终点指的是有向矢量的起始和箭头指向点**，而**顶点的终点指的是防止回路的那个人为定义的边结束点**。这段代码的意义就是按照图中红色箭头顺序寻找终点的过程，怎么实现的呢？在加入边后为每一个新增边的起点指派终点：如图所示：

- 【新增边的起点】的【终点】是【新增边的终点】；

- 【新增边的终点】的【终点】是【0】；

当查询时，就一直找这个点的终点，直到哪个点的终点是0了，那它就是有关联，且最新增的边的终点。查询时具体是：如果一个边还没加入结果集合，其两个顶点的终点都是 0 。所以，如果 ends[i] != 0，那么循环让<mark> i = ends[i];</mark>，由于在取边时的赋值操作，ends数组会循环到第一个ends为0的顶点，并返回此顶点。如右图，DE边加入后，如果再想加入FD，肯定要先判断D和F的终点。 D 在找终点 getends[D] 时，会循环： i = ends[ i ] ：

-  i0 = D, ends[i0] = ends[D] = E；
-  i1 = E, ends[i1] = ends[E] = F ；
-  i2 = F, ends[i2] = ends[F] = 0，退出循环，返回i2，即F；

这表明 D 的终点是 F 。整个 Kruskal 算法的流程图如下：

![flowChart06.png](/images/flowChart06.png "flowChart-Kruskal"){: .align-center}

## 七、迪杰斯特拉 (Dijkstra) 算法 - 最短路径

应用场景：最短路径问题

有 7 个村庄 (A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄，各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里。问：如何计算出 G 村庄到 其它各个村庄的 最短距离? 如果从其它点出发到各个点的最短距离又是多少？即：某个点出发，到另一个点的最短距离。显然 G - A 是直达，很简单，但 C - D 就不好说了。问题还是很有实际意义的，比如坐地铁算出最短路径等。

迪杰斯特拉（Dijkstra）算法是典型的最短路径算法，用于 计算一个结点到其他结点的最短路径。 它的主要特点是 **以起始点为中心向外层层扩展 (广度优先搜索思想)**，直到扩展到终点为止。由于 BFS 是一层一层计算，所以会反映本层到下一层的最短路径。

### 算法流程

用到了三个数组：V记录顶点, dis记录距离，还有记录前驱的数组。设：

- **v**：出发顶点

- **V**：为顶点集合 V { v1,v2, ... , vi }

- **dis**：出发点 v 到 V 中其他各个顶点的距离 dis{ d1,d2, ... , di }。到自身（v 到 v）的距离为 0，v 到 Vi 的距离为 di

算法过程如下：

1. 从 dis 中选择值最小的 di 并移出 dis 集合，同时移除 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径；
2. 更新 dis 集合，更新规则为：比较【v 到 V 集合中顶点的距离】与 【v 通过 vi 到 V 集合中顶点的距离值】，保留较小的一个（同时也应该更新顶点的 前驱节点 为 vi，表明是通过 vi 达到的v。）
3. 重复执行两步骤，直到最短路径顶点为目标顶点即可结束；

为什么要有前驱结点？因为当前的道路不一定最短，随时调整，回溯。知道了前驱就能调整访问结点的顺序。比如从 G 点出发，会访问 G,A、G,B、G,E、G,F，那么 A、B、E、F 的前驱节点就是 G。 dis 数组记录**当前从起点到其他所有顶点的最短距离**，Dij算法就是不停动态更新这三个数组，得到最终结果。最重要的是 dis 数组，通过不停**维护 dis 数组**，保证每次加入新结点，都能已知起点到各结点的最短路径。图解如下：

![dij01.png](/images/dij01.png "图解Dij算法"){: .align-center}

### 代码实现

核心算法包括1）选取下一个访问节点，2）加入新节点后路线距离的变化，代码如下：

{% highlight js %}
// ----- 选择下一个访问节点 -----
public int updateArr(){
        int minLen = 65535, index = 0;
        for (int i = 0;i<already_arr.length;i++){
            if (already_arr[i] == 0 && dis[i] < minLen){
                // 找到所有没访问过的节点，并找dis里的最小
                minLen = dis[i];
                index = i;
            }
        }
        already_arr[index] = 1;// 代码中唯一更新already的地方
        return index;
    }

// ----- 访问新节点后路径的变化 -----
private void update(int index){
        int len;
        for (int j = 0;j<matrix.length;j++){
            // vv.getDis(j) 是【起点到j的距离】
            // len = vv.dis[index] + matrix[j][index]是新路线，即【起点先到index，再到j的距离】
            // 如果新路线更短，就更新两个数组，否则不用管；
            len = vv.dis[index] + matrix[j][index];

            if(!vv.in(j) && len < vv.getDis(j)){
                vv.updateDis(j,len); // 定下来了，从初始点到j的最短路就是len
                vv.updatePre(j,index);// 定下来了，index就是j的前驱
            }
        }
    }

{% endhighlight %}


最后，迪杰斯特拉算法的流程图：

![flowChart07.png](/images/flowChart07.png "Dij算法-flowChart"){: .align-center}

- 现在再看 dis[] 数组，它表示引入当前这些结点（already表示）的情况下，起点到所有结点的最优路线。比如对上面的图而言，最初只有起点时， dis 是起点到所有点的最短距离，可以看出C和D点是不可达的，因为现在只访问了 G ，并没有通路。当加入 A 后，G 到 C 的最短距离变成了 G-A-C，即 9 ，现在 C 的前驱是 A 。又加入 E 后，到 C 的路线又多了一条 G - E - C 。然而距离更长，因此 dis[2] 没有更新，仍然是先前的 9 。

- 注意，如果新节点的引入使【起点到某个结点的路线】变短，那么更新这个距离以及，新节点作为前驱（最后展示路线）。如果新节点带来的新路线并不是最短，那除了已访问以外，其他无需更新，上一种情况（没new）时的最优路线现在仍然最优。

- 找新的访问结点时有两个条件：1）没访问过，2）当前的最短。那么，1）这个条件是否会使一些最优路线被忽略了？其实是没有的，理论上来说图中所有边都会被考虑一遍。



## 八、弗洛伊德算法

## 九、

## 十、骑士周游




