---
layout: post
title: "赫夫曼树"
author: LJC
tags:
- Java
date: 2022-09-28 10:00 +0800
toc: true
---

## 前置概念

### 路径和路径长度：

&emsp;&emsp;1) 路径：在一颗树中，从一个节点往下可以到达的孩子或孙子节点之间的通路，称为**路径**。

&emsp;&emsp;2) 路径长度：通路中**分支（不算根）**的数目。

### 结点的权及结点的带权路径长度：

&emsp;&emsp;3) 权：若将树中节点赋给一个有着某种函数的数值，则这个数值称为该节点的**权**。

&emsp;&emsp;4) 结点的带权路径长度：**从根节点到该节点之间的路径长度**与该节点的**权**的**乘积**。

&emsp;&emsp;如图，仅对6节点而言: 
&emsp;&emsp; 1) 从root到6节点的红色箭头为**路径**；
&emsp;&emsp; 2) **权**为6；
&emsp;&emsp; 3) **路径长度**为4-1=3，即从根节点到4层的路径长度为3(指的是分支的长)；
&emsp;&emsp; 4) **带权路径长度**为：3*6=18；

![def01.png](/images/def01.png "define"){: .align-center}

### 树的带权路径长度(weighted path length)

&emsp;&emsp;树的带权路径长度是**所有<mark>叶子节点</mark>的带权路径长度之和**，记为**WPL**。鉴于要与路径长度相乘，因此**权值越大的节点离根节点越近，二叉树越接近最优**。叶子节点相同，但树形状不同的WPL如图：
![wpl01.png](/images/wpl01.png "Tree_WPL"){: .align-center}

## 赫夫曼树

&emsp;&emsp;n个叶子节点和分别n个权值，如果树的**带权路径长度(wpl)**达到最小，则称为最优二叉树/赫夫曼树(Huffman Tree)。

&emsp;&emsp;赫夫曼树是带权路径长度最短的树，权值较大的节点离根节点较近（这样wpl才能最小）

### 图解构建赫夫曼树

&emsp;&emsp;赫夫曼树的构建流程图：
![chart02.png](/images/chart02.png "流程图"){: .align-center}

&emsp;&emsp;其中循环部分的图解如下，整体思想是把**大数留到最后(离根最近的地方)**处理，每次先安置最小的两个数：
![heffTreeCons.png](/images/heffTreeCons.png "赫夫曼树的构建过程"){: .align-center}

&emsp;&emsp;赫夫曼树的构建步骤：

1. 将数列从小到大进行排序

2. 取出根节点权值最小的两颗树

3. 组成一颗新的二叉树，该二叉树的根节点权值为这两节点的**权值之和**

4. 将这颗新的二叉树以**根节点**的权值大小再次排序，并重复上述步骤，直到数组的所有数都被处理

&emsp;&emsp;**构建部分的代码**：
{% highlight js %}
    public static Node createHuffmanTree(int[] arr){
        ArrayList<Node> nodeSet = new ArrayList<>();
        for (int i =0; i< arr.length;i++){
            nodeSet.add(new Node(arr[i]));
        }
        // 循环，直到只剩下一个节点（根/WPL）
        while (nodeSet.size() > 1) {
            // 1. 排序：从小到大，由于node实现了comparable接口，可以放进去
            Collections.sort(nodeSet);
            // 2. 取出权值最小的两个节点
            Node minLeft = nodeSet.get(0);
            Node minRight = nodeSet.get(1);
            // 3. 构建一颗新的二叉树
            Node minParent = new Node(minLeft.value + minRight.value);
            minParent.left = minLeft;
            minParent.right = minRight;
            // 4. 删除已经处理过的两个节点，增加新节点
            nodeSet.remove(minLeft);
            nodeSet.remove(minRight);
            nodeSet.add(minParent);
        }
        return nodeSet.get(0);
    }

{% endhighlight %}

## 赫夫曼编码

利用赫夫曼树的结构形成的编码方式，属于一种**程序算法**。分为两部分介绍：**频率相关 + 前缀不重复**。

### 1.定长编码
&emsp;&emsp;传递字符实际是以数字形式传递的，每个字母都有对应数字，这种对应形式，首先想到了ASCII码。

{% highlight js %}
// 原始字符，共40个字符(包括空格) 
i like like like java do you like a java     
// 对应 Ascii 码（32是空格，105是i...）
105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97  
// Ascii 码对应的二进制
01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001
{% endhighlight %}

计算机是按照二进制来传递消息的，上述消息的总长度是359，显然太长了。

### 2.变长编码：频率相关

&emsp;&emsp;显然有的字母出现次数多，有的出现次数少，多的如'e', 't'，少的有'z', 'q'等，摩尔斯电码中常用字母对应的电码更简单。这种**字母使用与频率相关联**的编码方式会节省许多长度。

{% highlight js %}
// 原始字符，共40个字符(包括空格) 
i like like like java do you like a java  
// 各个字符对应的个数
d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5  /space:9 
// 按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了 9 次， 编码为 0 ,其它依次类推.
// 等号前面的数字就是就是赫夫曼树节点的带权路径，后面讲解为什么
0=  ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d
{% endhighlight %}

### 3.前缀不相关

&emsp;&emsp;但是，在翻译编码的过程中，可能会出现一些问题，比如：

> 101=' l ', 1=' a ', 0= /space

> 那么，101 是等于 " l "，还是 101 = " a a "呢 ？如何区分？

&emsp;&emsp;很容易想到的一种改进方式是在表示字符的0和1之外，加入第三种符号表示字符的间隔，如 1/0/1，1_0_1 等。但是计算机中只有0和1，有什么方法不需要用另外加入也可以让一连串编码只能表示出一种意思吗？既然我们不能多引入编码的符号，我们可以在编码中加入限制。考虑如下的编码方式：

> A = 101 ， B = 101001 ， C = 01

&emsp;&emsp;考虑" BC "的编码" 101001001 "。在计算机一个一个读取时：
- 1，查表失败，继续读取
- 10，查表失败，继续读取
- 101，对应字符A，清空后继续读取
- 0，查表失败，继续读取
- 00，查表失败，继续读取

&emsp;&emsp;直到扫描完，都没有找到对应字符。出现问题是因为，A的编码是B编码的**前缀**。计算机只管查表，然后翻译读到的某段编码。所以当某个编码是另一个编码前缀，并且没有第三个符号分割的话，计算机是无法读取更长编码对应的字符的。为了不引入第三个字符，我们要求**每个字符对应的编码都不能是其他字符编码的前缀（prefix-free）**。

&emsp;&emsp;上面的编码方式只用两个符号和前缀不重复这两个特征。恰好我们可以用二叉树的结构来表示，如下图。从根结点开始往下走，向左走为0，向右走为1。字符的编码就是根节点到该字符所在结点的路径编码。把需要编码的字符放在一颗树的叶子结点（无左子树和右子树），那么就不可能出现编码是别人的前缀。（假如' A '的编码是' B '的编码的前缀，那么去B的过程就会经过A，那么A就不是叶子结点，这与假设矛盾）。

> A = 11   B = 00   C = 010   D = 100   R = 011   ! = 101

![prefixFree.png](/images/prefixFree.png "前缀不重复")

### 4.赫夫曼编码

&emsp;&emsp;尽管现在可以正常编码了，但是不同编码方式所用的内存不同。现在我们的新目标是，结合**频率相关和前缀不重复**，构建一颗**针对某一文本最优**的二叉树，我们自然想到了赫夫曼树。可以统计文本中各字符出现的次数，将字符按照频数升序排序，频数作为节点的权值，以此构成一颗赫夫曼树。思想是以根节点到该字符所在结点的路径为该字符编码，不可能出现冲突。出现次数最多的字母(如 e,a..)离根近一些。如上图中频率高的字母 a=11 ，而频率不高的 c=010 比a长，以边长编码达到减少码长的目的。

{% highlight js %}
// 1. 原始字符，共40个字符(包括空格) 
i like like like java do you like a java  

// 2. 各个字符对应的个数
d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   空格:9

// 3. 根据权值生成赫夫曼树，编码如下：
o: 1000   u: 10010   d: 100110   y: 100111   i: 101   a: 110    k: 1110    e: 1111     j: 0000    v: 0001   l: 001    : 01

// 4. 字符串对应的编码为 (注意这里我们使用 无损压缩)
// 1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110
 
{% endhighlight %}

&emsp;&emsp;此编码总长度为：133，原始的定长编码长度为 359，压缩了 359-133/359=62.9%。注意：鉴于赫夫曼树中的排序属于不稳定排序，树有一些差异，由此对应的赫夫曼编码也不一样，但是压缩效率都是一样的。比如频数为：[ 4,4,4,4,4,4,4,5,6,7 ]，不能确定 哪个4在左，哪个4在右？不稳定，但是**WPL不变，压缩程度一致**。

## 数据压缩（编码）

&emsp;&emsp;首先根据赫夫曼编码压缩数据的原理，创建字符串对应的赫夫曼树。节点类要具有数据域和权值属性。思路为：

- 将原始字符串先转成 byte 数组，再把 byte 数组转成 赫夫曼编码对应的值

- 将赫夫曼编码字符串，转成 byte 数组，因为**数据发送也是通过 byte 二进制发送的**

&emsp;&emsp;赫夫曼编码进行数据压缩的流程如图，可能<mark>涉及到二进制转码：原码、补码、反码</mark>：

![chart03.png](/images/chart03.png "赫夫曼数据压缩"){: .align-center}

&emsp;&emsp;整个过程中数据的流转形式：

![chart04.png](/images/chart04.png "数据形式"){: .align-center}

{% highlight js %}
"i like like like java do you like a java"
length before zipping: 40
Before: [105, 32, 108, 105, 107, 101, 32, 108, 105, 107, 101, 32, 108, 105, 107, 101, 32, 106, 97, 118, 97, 32, 100, 111, 32, 121, 111, 117, 32, 108, 105, 107, 101, 32, 97, 32, 106, 97, 118, 97]
赫夫曼编码表: {32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}
After: [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
length after zipping: 17
Zipping rate：0.575
{% endhighlight %}

## 数据压缩（解码）

&emsp;&emsp;依然是 Byte[ ] => Byte[ ] => String 。按上图的倒序，第一步是转成二进制码，第二步对照编码表，重新转成Byte[ ]，最后转成String。