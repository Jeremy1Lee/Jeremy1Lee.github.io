---
layout: post
title: "计网 Ch5：运输层-2"
author: LJC
tags:
- network
date: 2022-11-02 11:20 +0800
toc: true
---

# 运输层 (Transport layer) - Part2

## 7. TCP 可靠传输的实现

TCP 基于**以字节为单位的滑动窗口**来实现可靠传输。

> 依然假定只在一个方向进行数据传输：一个发一个确认；并且，假定网络不存在拥塞问题【即发送窗口只考虑接收窗口即可，不用考虑拥塞窗口】

**TCP 可靠传输的实现流程：**

既然是以字节为单位，如图是待发送的字节序号以及接收方发来的确认字段，表明接收窗口宽度20（发送窗口也设置成20），31以前的都确认无误，下一个希望收到31。
- ![slide01.png](/images/net/slide01.png "Sliding Window")

此时来看一下发送窗口：
- ![slide02.png](/images/net/slide02.png "Sliding Window2")

发送窗口的**前沿和后沿**有以下可能的变化方式：
- ![slide03.png](/images/net/slide03.png "Sliding Window3")

现在假设发送方把 31-41 的字节封装在几个报文段里发了出去（图中蓝色字节），而 41-50是允许发送但还未发送的：
- ![slide04.png](/images/net/slide04.png "Sliding Window4")

如何标记和维护滑动窗口的状态呢？—可以使用三个指针分别指向相应的字节序号，如下图：
- ![slide05.png](/images/net/slide05.png "Sliding Window5")

再来看接收窗口（尺寸20），假设封装有32，33号数据的报文段到达了接收方，由于在接收窗口内，所以接收了它们，并存入接收缓存（红色）。但是31还没到，因此它们是未按序到达的数据：可能丢失/或者滞留在网络中了：
- 由于接收方只能对按序收到的数据中的**最高序号**给出确认，因此确认报文中的确认序号仍然是31
    - ![slide06.png](/images/net/slide06.png "Sliding Window6")

发送方收到确认报文，发现这是对 31 号数据的**重复确认**，知道了接收方收到了未按序到达的数据。
- 由于这是对 31 号数据的**第一个重复确认**，并不会引起 发送方对31号数据 快重传（三个才重传）；

假设现在 31 号到达接收方了，交付给进程，然后接收窗口**前移三个**，并发送确认报文段，表明已经收到了33 为止的全部字段，接下来想收到34了：
- ![slide07.png](/images/net/slide07.png "Sliding Window7")

接下来又有几个未按序到达的数据，只能暂存在接收缓存中
- ![slide08.png](/images/net/slide08.png "Sliding Window8")

发送方将发送窗口向前滑动三个序号，尺寸不变，可将31-33从缓存中删除。继续将42-53的数据封装在几个不同报文段发送出去，序号用完了，没有新的确认不会再发送了。
- 注意，已发送数据如果迟迟收不到确认，则会产生**超时重传**；
- ![slide09.png](/images/net/slide09.png "Sliding Window9")

**注意事项：**
1. 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，**发送方的发送窗口并不总是和接收方的接收窗口一样大**。
    - 因为传输窗口值的改变有一定的时间滞后，时间不确定。
    - 发送窗口还受**拥塞情况(拥塞窗口)**影响；
2. TCP 并**没规定对于不按序到达的数据的处理方法**
    - 如果直接丢弃不按序到达的数据，管理起来比较简单，但对网络资源利用不利，因为重传任务变多了；
    - TCP 通常对不按序到达的数据：临时存在接收窗口中，等**缺少的字节到达后，再按序交付给进程**；
3. TCP 要求接收方必须有**累积确认和捎带确认机制**，这样可以减小传输开销。接收方可以在合适的时候发送确认（推迟一会再确认），也可以在自己有数据要发送时捎带确认信息
    - 但是接收方不能过分推迟发送确认，这样导致不必要的超时重传，浪费网络资源
        -  TCP 规定推迟确认时间不能超过0.5秒，若收到一连串最大长度的报文段，则必须每隔一个报文段就发送一个确认。
    - 捎带确认机制实际上很少发生，因为大多数应用程序很少同时在两个方向上发送数据（全双工）
4. TCP是全双工通信，每一方都既发送又接收，每方都有发送和接收窗口，【明确哪一方的哪个窗口】

-------------------

## 8. TCP 的运输连接管理

## - 8.1 TCP 的连接建立 






- ![slide10.png](/images/net/slide10.png "Sliding Window10")










-----------------

## - 8.2 TCP 的连接释放













-----------------
## 9. TCP 报文段的首部格式