---
layout: post
title: "【计网】Ch5：运输层-2"
author: LJC
tags:
- network
date: 2022-11-02 11:20 +0800
toc: true
---

# 运输层 (Transport layer) - Part2

## 7. TCP 可靠传输的实现

TCP 基于**以字节为单位的滑动窗口**来实现可靠传输。

> 依然假定只在一个方向进行数据传输：一个发一个确认；并且，假定网络不存在拥塞问题【即发送窗口只考虑接收窗口即可，不用考虑拥塞窗口】

**TCP 可靠传输的实现流程：**

既然是以字节为单位，如图是待发送的字节序号以及接收方发来的确认字段，表明接收窗口宽度 20（发送窗口也设置成 20），31 以前的都确认无误，下一个希望收到 31。
- ![slide01.png](/images/net/slide01.png "SlidingWindow")

此时来看一下发送窗口：
- ![slide02.png](/images/net/slide02.png "SlidingWindow2")

发送窗口的**前沿和后沿**有以下可能的变化方式：
- ![slide03.png](/images/net/slide03.png "SlidingWindow3")

现在假设发送方把 31-41 的字节封装在几个报文段里发了出去（图中蓝色字节），而 41-50 是允许发送但还未发送的：
- ![slide04.png](/images/net/slide04.png "SlidingWindow4")

如何标记和维护滑动窗口的状态呢？—可以使用三个指针分别指向相应的字节序号，如下图：
- ![slide05.png](/images/net/slide05.png "SlidingWindow5")

再来看接收窗口（尺寸 20），假设封装有 32，33 号数据的报文段到达了接收方，由于在接收窗口内，所以接收了它们，并存入接收缓存（红色）。但是 31 还没到，因此它们是未按序到达的数据：可能丢失 / 或者滞留在网络中了：
- 由于接收方只能对按序收到的数据中的**最高序号**给出确认，因此确认报文中的确认序号仍然是 31 :
    - ![slide06.png](/images/net/slide06.png "SlidingWindow6")

发送方收到确认报文，发现这是对 31 号数据的**重复确认**，知道了接收方收到了未按序到达的数据。
- 由于这是对 31 号数据的**第一个重复确认**，并不会引起 发送方对 31 号数据 快重传（三个才重传）；

假设现在 31 号到达接收方了，交付给进程，然后接收窗口**前移三个**，并发送确认报文段，表明已经收到了 33 为止的全部字段，接下来想收到 34 了：
- ![slide07.png](/images/net/slide07.png "SlidingWindow7")

接下来又有几个未按序到达的数据，只能暂存在接收缓存中
- ![slide08.png](/images/net/slide08.png "SlidingWindow8")

发送方将发送窗口向前滑动三个序号，尺寸不变，可将 31-33 从缓存中删除。继续将 42-53 的数据封装在几个不同报文段发送出去，序号用完了，没有新的确认不会再发送了。
- 注意，已发送数据如果迟迟收不到确认，则会产生**超时重传**；
- ![slide09.png](/images/net/slide09.png "SlidingWindow9")

**注意事项：**
1. 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，**发送方的发送窗口并不总是和接收方的接收窗口一样大**。
    - 因为传输窗口值的改变有一定的时间滞后，时间不确定。
    - 发送窗口还受**拥塞情况（拥塞窗口)**影响；
2. TCP 并**没规定对于不按序到达的数据的处理方法**
    - 如果直接丢弃不按序到达的数据，管理起来比较简单，但对网络资源利用不利，因为重传任务变多了；
    - TCP 通常对不按序到达的数据：临时存在接收窗口中，等**缺少的字节到达后，再按序交付给进程**；
3. TCP 要求接收方必须有**累积确认和捎带确认机制**，这样可以减小传输开销。接收方可以在合适的时候发送确认（推迟一会再确认），也可以在自己有数据要发送时捎带确认信息
    - 但是接收方不能过分推迟发送确认，这样导致不必要的超时重传，浪费网络资源
        -  TCP 规定推迟确认时间不能超过 0.5 秒，若收到一连串最大长度的报文段，则必须每隔一个报文段就发送一个确认。
    - 捎带确认机制实际上很少发生，因为大多数应用程序很少同时在两个方向上发送数据（全双工）
4. TCP 是**全双工通信**，每一方都既发送又接收，每方都有发送和接收窗口，【明确哪一方的哪个窗口】

-------------------

## 8. TCP 的运输连接管理

TCP 是面向连接的协议，基于运输连接来传送 TCP 报文段。
- **TCP 连接的建立和释放** 是每一次**面向连接**的通信必不可少的过程；
- TCP 运输连接有以下三个阶段：
    - ① 建立 TCP 连接：**三报文握手** ；
    - ② 数据传送：基于 TCP 连接，可靠传输；
    - ③ 释放 TCP 连接：**四报文挥手** ；
    - ![tcpL01.png](/images/net/tcpL01.png "TCP的运输连接管理-三部分")
-  TCP 的运输连接管理就是使运输连接的**建立和释放**都能正常运行；

## - 8.1 TCP 的连接建立 

TCP 的连接建立要解决以下三个问题：
1. 使 TCP 双方能感知到彼此存在；
2. 使 TCP 双方能**协商一些参数**（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等）；
3. 使 TCP 双方能够**对运输实体资源进行分配**（如缓存大小，连接表中的项目等）；

### TCP 三报文握手 —— 建立连接

如图，两个要基于 TCP 通信的主机，一台的进程主动发起 TCP 连接建立，称为 **TCP 客户**，另一台被动等待建立的进程称为 **TCP 服务器**。
- ![tcpL02.png](/images/net/tcpL02.png "TCP客户和服务器")

我们将 TCP 建立连接的过程比喻为“**握手**”，它**需要在客户和服务器之间交换三个 TCP 报文段**。

（一）最初，两端的 TCP 进程都处于关闭状态。做一些准备工作：
- TCP 服务器进程创建**传输控制块**，用来存储 TCP 连接中的一些重要信息；
    - 如 TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针等，如图；
- 此后准备接收 TCP 客户进程的连接请求，TCP 服务进程进入**监听状态**，等待连接请求。
- TCP 服务进程是被动等待，不是主动发起，称为**被动打开连接**
- TCP 客户进程也是首先创建传输控制块。
- ![tcpL03.png](/images/net/tcpL03.png "TCP-1服务进程")

<br/>

（二）TCP 客户进程在打算建立 TCP 连接时，向 TCP 服务器进程发送 **TCP 连接请求报文段**，并进入**同步已发送状态**。TCP 连接请求报文段的 首部中：
- **同步位 SYN** 设为 1，表明这是一个 TCP 连接请求报文段；
- **序号字段 seq** 设为初始值 x，它是 **TCP 客户进程**所选择的**初始序号** ；
    - 【注意】TCP 规定 SYN=1 的报文段不能携带数据，但要消耗（用掉）一个序号 seq ；
- ![tcpL04.png](/images/net/tcpL04.png "TCP-2客户进程")
- TCP 客户进程是主动发起，称为**主动打开连接**；

<br/>

（三）TCP 服务器进程收到 TCP 连接请求报文段后，如果 <mark>同意建立连接</mark>，则向 TCP 客户进程发送 **TCP 连接请求确认报文段**，并进入**同步已接收状态**：
- **同步位 SYN** 和 **确认位 ACK** 都 = 1 ，表明这是一个 TCP 连接请求确认报文段；
- **序号字段 seq** 设为初始值 y，它是 **TCP 服务器**进程所选择的**初始序号**；
- **确认号字段 ack** 的值设置为 **x+1** ，它是对 TCP 客户进程选的初始序号（即：x）的确认（x+1 是 x+1 前的都确认的意思）；
- 【注意】这个报文段也不能携带数据（因为 SYN=1），同样消耗掉一个序号 seq ; 
- ![tcpL05.png](/images/net/tcpL05.png "TCP-3")

<br/>

（四）TCP 客户进程收到 TCP 连接请求确认报文段后，还要向 TCP 服务器进程发送一个**普通的 TCP 确认报文段**，并进入**连接已建立状态**；
- **确认位 ACK = 1** ，表明这是一个**普通的 TCP 确认报文段**；
- **序号字段 seq** 设置为 x+1，因为客户进程发的第一个 TCP 报文的 seq 序号为 x （下图黄色标出），而且**不携带数据（不消耗seq序号）**，因此如果接下来还发报文段，序号还是 x+1 ；
    - 【注意】TCP 规定普通的 TCP 确认报文段可以携带数据，也可以不带数据，**如果不带数据，不消耗序号**，下一个普通 TCP 报文段的序号 seq 和这个不带数据的 seq 可以一样；
- 确认号字段 ack 的值设置为 y+1 ，是对 TCP 服务进程所选择的初始序号（即：y）的确认（图中红色）  ；
- ![tcpL06.png](/images/net/tcpL06.png "TCP-4")
- 如图，红色 ack 值的来源对应红色 seq，黄色 seq 对应黄色 seq；

<br/>

（五）TCP 服务器进程收到 TCP 连接请求报文段后，也进入**连接已建立状态**（图中绿色状态），现在双方都进入了连接已建立状态，它们可以基于建立好的 TCP 连接进行可靠的数据传输了。
- ![tcpL07.png](/images/net/tcpL07.png "TCP-5")

### 为什么三次握手而不是两次？

现在问题来了：为什么最后还要发一个普通的 TCP 确认报文段呢？即为什么是三次握手而不是两次？两次握手能建立连接吗？——显然不可以，看这个例子：

1）客户进程发出 TCP 连接请求报文段 ，但这个报文滞留了，必然会造成**超时重传**。而重传的报文段则被正常接收了：
- ![tcpL08.png](/images/net/tcpL08.png "TCP两握手-1")
 
2）服务器进程给客户进程发一个 TCP 连接请求确认报文段 ，客户进程收到之后，双方都进入连接已建立状态，但不会回复确认（现在是两次握手）。现在它们可以传输数据，然后释放连接，双方都处于了关闭状态。
- ![tcpL09.png](/images/net/tcpL09.png "TCP两握手-2")
 
3）一段时间后，此前滞留的 TCP 连接请求报文段 到达了服务器进程。它会误以为这是客户进程 又发起的新 TCP 连接请求，于是回复了 TCP 连接请求确认报文段，并进入连接已建立状态。
- ![tcpL10.png](/images/net/tcpL10.png "TCP两握手-3")

4）但是客户端不会理会这个报文段，而服务器仍在 连接已建立状态，会以为新的连接已经建立好了，并一直等着客户进程发来数据，浪费主机的资源。

综上所述，使用三次握手而**不是两次，是为了防止已失效的连接请求报文段又传送到了 TCP 服务器**，因而导致错误。
- ![tcpL11.png](/images/net/tcpL11.png "TCP两握手-4")

-----------------

## - 8.2 TCP 的连接释放，以及保活

TCP 通过**四报文挥手**来释放连接。

### TCP 四报文挥手 —— 释放连接

现在，用户和服务器都处于连接已建立状态：
- ![tcpL12.png](/images/net/tcpL12.png "连接已建立")

（一）假设客户进程的应用进程通知其主动关闭 TCP 连接，客户进程发送 **TCP 连接释放报文段**，并进入**终止等待 1 状态**（后面还有终止等待2）。
- **终止位 FIN 和确认位 ACK** 都 =1 ，表明这是一个 TCP 连接释放报文段，同时也对之前收到的报文段进行确认；
- **序号字段 seq** 设为 u ，**u = 客户进程之前已传送数据的最后一个字节的序号 +1** ；
    - 【注意】TCP 规定：终止位 FIN = 1 的报文段即使不携带数据，也要消耗掉一个序号 seq ;【后面有对应，在（四）】
- **确认号 ack 字段**的值设为 v ，**v = 客户进程之前已收到数据的最后一个字节的序号 +1** ；
- ![tcpL13.png](/images/net/tcpL13.png "发送 TCP 连接释放报文段")

<br/>

（二）服务器进程收到 TCP连接释放报文段 后，会发送一个 **普通的TCP确认报文段**，并进入**关闭等待状态**。该报文段首部中：
- **确认位 ACK = 1** ，表明这是一个普通的 TCP 确认报文段；
- **序号字段 seq** = v ，**v = 服务器进程之前已传送过数据的最后一个字节的序号 +1** （与上面的确认号 ack 相匹配，不是v+1）；
- **确认号 ack 字段**设为 u+1，说明这是对 TCP 连接释放报文段的确认。
- ![tcpL14.png](/images/net/tcpL14.png "发送 普通的TCP确认报文段")

TCP 服务器进程此时应该通知其高层应用进程（享受TCP服务的进程）：客户进程要断开与自己的TCP连接。
- 此时**从客户进程到服务器进程的连接就释放/关闭了**，即：客户进程没有数据要发送了；
- 但如果服务器进程还有数据要发送，客户进程仍要接收；
- 即：**从服务器到客户的连接还未关闭**，现在是**单向**的数据传输；
- ![tcpL15.png](/images/net/tcpL15.png "只剩下单向了")

客户进程收到 TCP 确认报文后就进入**终止等待2**状态，等待服务器进程发出的 **TCP 连接释放报文段**。如果服务器进程已经没有数据要发送了（等上图紫色报文段完结），应用层进程就通知TCP服务器进程 释放连接。由于是客户进程发起的释放TCP连接，因此服务器进程对TCP连接的释放称为**被动关闭连接**。
- ![tcpL16.png](/images/net/tcpL16.png "终止等待2状态")

<br/>

（三）TCP 服务器进程发送 **TCP 连接释放报文段**，并进入**最后确认状态**。该报文段首部中：
- **终止位 FIN 和确认位 ACK** 都 =1 ，表明这是一个 TCP 连接释放报文段，同时也对之前收到的报文段进行确认；
- **序号字段 seq** 设为 w ，因为在半关闭状态下，服务器进程可能又发送了一些数据（上图紫色报文段，从v到w）；
- **确认号 ack 字段**的值设为 u+1 ，这是对之前收到的 TCP 连接释放报文段 的重复确认
- ![tcpL17.png](/images/net/tcpL17.png "最后确认状态")

<br/>

（四）客户进程收到 **TCP 连接释放报文段** 后，必须针对该报文段发送 **普通的TCP确认报文段**，然后进入**时间等待状态**。该报文段首部中：
- **确认位 ACK = 1** ，表明这是一个普通的 TCP 确认报文段；
- **序号字段 seq** = u+1 ，因为客户进程之前发送的 TCP 连接释放报文段虽然不携带数据，但要消耗掉一个序号；【对应（一）中对应伏笔】
- **确认号 ack 字段**设为 w+1，这是对所收到的 TCP 连接释放报文段的确认。(再次印证不是w)
- ![tcpL18.png](/images/net/tcpL18.png "时间等待状态")

<br/>

（五）服务器进程收到该报文段后进入**关闭状态**，而客户进程还要经过 **长为 2MSL 的时间等待状态** 后才能进入关闭状态（常为4分钟），这完全是从工程上来考虑的。
- MSL ：最长报文段寿命，建议为 2 分钟，也可根据情况使用更小的 MSL 值；
- ![tcpL19.png](/images/net/tcpL19.png "关闭状态")

至此，TCP 客户进程和 TCP 服务器进程都关闭了。

### 客户服务器有必要等待再关闭吗？

问题又来了，必须要经过 2MSL 的时间等待再关闭吗？

现在假设：四报文中的最后一个报文 发出去了，客户进程立即就关闭状态：
- 如果最后的确认报文丢失了，服务器进程等不到确认势必要超时重传，并仍处于最后确认状态
- ![tcpL20.png](/images/net/tcpL20.png "如果直接关闭")
- 到达客户进程，但其已经处于关闭状态了，不会理睬该报文；

这必然导致服务器进程反复重传，并始终处于最后确认状态无法关闭；
- ![tcpL21.png](/images/net/tcpL21.png "无法关闭")

综上，时间等待状态以及处于该状态 2MSL 时长可以确保 **服务器进程能收到最后一个确认报文段而顺利进入关闭状态**。另外，经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，在下一个新的TCP连接中**不会出现旧连接中的报文段**。

**TCP 的保活计时器**

最后，再看看TCP中**保活计时器**的作用。

现在，双方已经建立了连接，但客户进程所在的主机突然出现了故障。显然服务进程再也收不到客户进程发来的数据。因此有必要采取措施使 服务器进程**不要再白等下去**。
- ![tcpL22.png](/images/net/tcpL22.png "保活计时器-场景")

服务器进程如何发现这种情况呢？——保活计时器
- 服务器进程每收到一次  客户进程的数据，就重新设置并启动**保活计时器**（2小时定时）；
- 若保活计时器定时周期内**未收到** 客户进程发来的数据，则**保活计时器到时后，服务器进程就向客户进程发送一个探测报文段**，以后每隔 75 秒发一次。
    - 若一连10个报文段后，客户进程仍无响应，服务进程就可认为客户进程所在主机出现了故障，接着关闭这个连接。

-----------------
## 9. TCP 报文段的首部（段头）格式

- 为了实现可靠传输， TCP 采用**了面向字节流**的方式，如图：TCP 将应用进程交付下来的应用报文看作是字节流，存入 TCP 发送缓存中；
- ![tcpH01.png](/images/net/tcpH01.png "发送场景")
- 但 TCP 发送数据时，是从发送缓存中**取出**一部分或全部字节 并给其添加一个首部使之成为 **TCP 报文段**后，再进行发送。（图中有2字节的，也有3字节的）
    - 一个 TCP 报文段由 **首部 和 数据载荷** 两部分组成；
    - TCP 的全部**功能**都**体现在**它首部中各**字段**的作用；

TCP 报文段的首部格式与 IP 数据报的首部格式类似，都是由 **20 字节的固定首部和 40 字节的扩展首部** 构成。
- ![tcpH02.png](/images/net/tcpH02.png "TCP 报文段的首部格式")

### 前两行：源/ 目的端口

![tcpH04.png](/images/net/tcpH04.png "TCP 报文段的首部前两行")

- 源端口（16 bit）：写入源端口号，标识 **发送**该 TCP 报文段的**应用进程**。

- 目的端口（16 bit）：写入目的端口号，标识 **接收**该 TCP 报文段的**应用进程**。

- 举例：如图，假设浏览器进程要访问 web 服务器中的 web 服务器进程（先不考虑ARP，DNS，TCP建立连接等）
    - 输入web域名，浏览器进程构建一个封装了HTTP请求报文的TCP报文段。该报头的源端口字段填写一个短暂端口号如 49152 ，标识发送该报文段的浏览器进程；目的端口字段填写熟知端口号 80 ，因为**使用HTTP协议的web服务器进程默认监听该端口**
    - web服务器收到该TCP报文后，解封出HTTP请求报文，根据目的端口80交付给web服务器进程，根据报文内容处理，构建响应报文；
    - ![tcpH03.png](/images/net/tcpH03.png "TCP 报文段的首部格式")

<br/>

### 与握手挥手相关的字段：序号，确认号，ACK，SYN

![tcpH11.png](/images/net/tcpH11.png "序号，确认号，ACK"){: .align-center}

- **序号 seq（32 bit）**：取值范围 [0, 2^32 -1] ，当序号增加到最后一个后，下一个序号回到 0 ；
    - 序号字段 ：用来指出**本 TCP 报文段数据载荷的第一个字节的序号**； 
    - 数据载荷中每个字节都有**序号**（面向字节），如图，第一个字节序号是166 ；
    - **序号与确认号 要相匹配**；
    - ![tcpH05.png](/images/net/tcpH05.png "序号")

- **确认号 ack（32 bit）**：取值范围 [0, 2^32 -1] ，当确认号增加到最后一个后，下一个序号回到 0 ；
    - 确认号：指出**期望收到对方下一个 TCP报文数据载荷 的第一个字节的序号，同时也是对之前收到的所有数据的确认** ；
        - 例如，确认号ack=n，表示 序号到 n-1 的所有数据都正确接收，期望接收序号为 n 的数据；
- ![tcpH06.png](/images/net/tcpH06.png "序号与确认号相匹配")

- **确认标志位 ACK** ：**只有确认标志位 ACK = 1 时，确认号字段才有效**；取值为 0 时确认号字段无效；
    - TCP 规定：**连接建立后，所有传送的 TCP 报文段都必须把 ACK 置 1**；

- **同步标志位 SYN**：在TCP连接建立时用来 同步序号；
    - SYN=1 ，表明这是 连接请求报文段；
    - SYN=1，ACK=1，表明这是 连接请求确认报文段；

- **终止标志位 FIN** ：释放TCP连接
    - FIN = 1，表明这是 TCP 连接释放报文段；

<br/>

### 其他字段

**第四行：数据偏移，窗口，短字段**

![tcpH10.png](/images/net/tcpH10.png "TCP 报文段的首部第4行"){: .align-center}

- **数据偏移（4 bit，单位为4字节）**：**以四字节为单位，指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远**。
    - 实际上就是  TCP 报文段的首部长度。
        - 首部长度固定20字节，除以单位4字节为5，因此数据偏移字段的最小值为 (0101)
        - 首部最长 60字节，除以单位4字节为15，因此数据偏移字段的最小值为 (1111)
        - 可以看出，4bit正好够用；
        - ![tcpH07.png](/images/net/tcpH07.png "数据偏移")

- **保留（6 bit）**：保留为今后使用，目前置为 0 ；
- **窗口（16 bit）**：以字节为单位，指出 **发送本报文段的一方 的接收窗口**
    - 窗口值是接收方让发送方设置其发送窗口的依据；
    - 以接收方的接收能力 来控制 发送方的发送能力，称为**流量控制**
        - 【注意】发送窗口大小应为 **Min(拥塞窗口，接收窗口)**

- **复位标志位 RST** ：复位TCP连接
    - **RST = 1 时，表明 TCP 连接出现了异常，必须释放连接，然后重新建立连接**；
    - RST = 1 还可以拒绝一个非法的报文段或拒绝打开一个TCP连接；
- **推送标志位 PSH** ：接收方的TCP收到PSH=1的报文段，**会尽快向上交付给应用进程**，而不必等到接收缓存都填满后再向上交付。

<br/>

**第五行：校验和，紧急指针**

![tcpH09.png](/images/net/tcpH09.png "TCP 报文段的首部第五行"){: .align-center}

- **校验和（16 bit）**：检查整个TCP报文段在传输过程中是否出现了误码；
    - 检查范围包括 首部和数据载荷 两部分；
    - 计算校验和时，在TCP 报文段前面加上12字节的伪首部；

- **紧急标志位 URG** ：实现紧急操作
    - URG = 1 时，紧急指针有效，取 0 则紧急指针无效；

- **紧急指针（16 bit）**：以字节为单位，指明紧急数据的长度；
    - 发送方**有紧急数据时**，可将**紧急数据插队到发送缓存的最前面**，并立刻封装到一个TCP报文段中进行发送。
    - 紧急指针 指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后才是普通数据。
    - 接收方收到 URG = 1 的紧急数据，从报文段中取出紧急数据，直接上交进程，而不必在缓存中排队。

<br/>

**最底行：选项（长度可变），填充**

![tcpH08.png](/images/net/tcpH08.png "TCP 报文段的首部最底行"){: .align-center}

- **选项**：增加选项可以增加TCP的功能
    - 最大报文段长度 MSS 选项：TCP 报文段数据载荷部分的最大长度；
    - 窗口扩大选项：为了扩大窗口（提高吞吐率）；
    - 时间戳选项：
        - 计算往返时间 RTT 
        - 处理序号超范围的情况，又称1为防止序号绕回 PAWS
    - 选择确认选项：实现选择确认；

- **填充**：由于选项长度可变，因此使用填充来**确保报文段整个首部能被 4 整除**；
    - 因为数据偏移表示的是首部长度字段是以4字节为单位的；


