---
layout: post
title: "计网 Ch5：运输层 -2"
author: LJC
tags:
- network
date: 2022-11-02 11:20 +0800
toc: true
---

# 运输层 (Transport layer) - Part2

## 7. TCP 可靠传输的实现

TCP 基于**以字节为单位的滑动窗口**来实现可靠传输。

> 依然假定只在一个方向进行数据传输：一个发一个确认；并且，假定网络不存在拥塞问题【即发送窗口只考虑接收窗口即可，不用考虑拥塞窗口】

**TCP 可靠传输的实现流程：**

既然是以字节为单位，如图是待发送的字节序号以及接收方发来的确认字段，表明接收窗口宽度 20（发送窗口也设置成 20），31 以前的都确认无误，下一个希望收到 31。
- ![slide01.png](/images/net/slide01.png "SlidingWindow")

此时来看一下发送窗口：
- ![slide02.png](/images/net/slide02.png "SlidingWindow2")

发送窗口的**前沿和后沿**有以下可能的变化方式：
- ![slide03.png](/images/net/slide03.png "SlidingWindow3")

现在假设发送方把 31-41 的字节封装在几个报文段里发了出去（图中蓝色字节），而 41-50 是允许发送但还未发送的：
- ![slide04.png](/images/net/slide04.png "SlidingWindow4")

如何标记和维护滑动窗口的状态呢？—可以使用三个指针分别指向相应的字节序号，如下图：
- ![slide05.png](/images/net/slide05.png "SlidingWindow5")

再来看接收窗口（尺寸 20），假设封装有 32，33 号数据的报文段到达了接收方，由于在接收窗口内，所以接收了它们，并存入接收缓存（红色）。但是 31 还没到，因此它们是未按序到达的数据：可能丢失 / 或者滞留在网络中了：
- 由于接收方只能对按序收到的数据中的**最高序号**给出确认，因此确认报文中的确认序号仍然是 31 :
    - ![slide06.png](/images/net/slide06.png "SlidingWindow6")

发送方收到确认报文，发现这是对 31 号数据的**重复确认**，知道了接收方收到了未按序到达的数据。
- 由于这是对 31 号数据的**第一个重复确认**，并不会引起 发送方对 31 号数据 快重传（三个才重传）；

假设现在 31 号到达接收方了，交付给进程，然后接收窗口**前移三个**，并发送确认报文段，表明已经收到了 33 为止的全部字段，接下来想收到 34 了：
- ![slide07.png](/images/net/slide07.png "SlidingWindow7")

接下来又有几个未按序到达的数据，只能暂存在接收缓存中
- ![slide08.png](/images/net/slide08.png "SlidingWindow8")

发送方将发送窗口向前滑动三个序号，尺寸不变，可将 31-33 从缓存中删除。继续将 42-53 的数据封装在几个不同报文段发送出去，序号用完了，没有新的确认不会再发送了。
- 注意，已发送数据如果迟迟收不到确认，则会产生**超时重传**；
- ![slide09.png](/images/net/slide09.png "SlidingWindow9")

**注意事项：**
1. 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，**发送方的发送窗口并不总是和接收方的接收窗口一样大**。
    - 因为传输窗口值的改变有一定的时间滞后，时间不确定。
    - 发送窗口还受**拥塞情况（拥塞窗口)**影响；
2. TCP 并**没规定对于不按序到达的数据的处理方法**
    - 如果直接丢弃不按序到达的数据，管理起来比较简单，但对网络资源利用不利，因为重传任务变多了；
    - TCP 通常对不按序到达的数据：临时存在接收窗口中，等**缺少的字节到达后，再按序交付给进程**；
3. TCP 要求接收方必须有**累积确认和捎带确认机制**，这样可以减小传输开销。接收方可以在合适的时候发送确认（推迟一会再确认），也可以在自己有数据要发送时捎带确认信息
    - 但是接收方不能过分推迟发送确认，这样导致不必要的超时重传，浪费网络资源
        -  TCP 规定推迟确认时间不能超过 0.5 秒，若收到一连串最大长度的报文段，则必须每隔一个报文段就发送一个确认。
    - 捎带确认机制实际上很少发生，因为大多数应用程序很少同时在两个方向上发送数据（全双工）
4. TCP 是**全双工通信**，每一方都既发送又接收，每方都有发送和接收窗口，【明确哪一方的哪个窗口】

-------------------

## 8. TCP 的运输连接管理

TCP 是面向连接的协议，基于运输连接来传送 TCP 报文段。
- **TCP 连接的建立和释放** 是每一次**面向连接**的通信必不可少的过程；
- TCP 运输连接有以下三个阶段：
    - ① 建立 TCP 连接：**三报文握手** ；
    - ② 数据传送：基于 TCP 连接，可靠传输；
    - ③ 释放 TCP 连接：**四报文挥手** ；
    - ![tcpL01.png](/images/net/tcpL01.png "TCP的运输连接管理-三部分")
-  TCP 的运输连接管理就是使运输连接的**建立和释放**都能正常运行；

## - 8.1 TCP 的连接建立 

TCP 的连接建立要解决以下三个问题：
1. 使 TCP 双方能感知到彼此存在；
2. 使 TCP 双方能**协商一些参数**（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等）；
3. 使 TCP 双方能够**对运输实体资源进行分配**（如缓存大小，连接表中的项目等）；

### TCP 使用三次握手建立连接的过程

如图，两个要基于 TCP 通信的主机，一台的进程主动发起 TCP 连接建立，称为 **TCP 客户**，另一台被动等待建立的进程称为 **TCP 服务器**。
- ![tcpL02.png](/images/net/tcpL02.png "TCP客户和服务器")

我们将 TCP 建立连接的过程比喻为“**握手**”，它**需要在客户和服务器之间交换三个 TCP 报文段**。

（一）最初，两端的 TCP 进程都处于关闭状态。做一些准备工作：
- TCP 服务器进程创建**传输控制块**，用来存储 TCP 连接中的一些重要信息；
    - 如 TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针等，如图；
- 此后准备接收 TCP 客户进程的连接请求，TCP 服务进程进入**监听状态**，等待连接请求。
- TCP 服务进程是被动等待，不是主动发起，称为**被动打开连接**
- TCP 客户进程也是首先创建传输控制块。
- ![tcpL03.png](/images/net/tcpL03.png "TCP-1服务进程")
<br/>

（二）TCP 客户进程在打算建立 TCP 连接时，向 TCP 服务器进程发送 **TCP 连接请求报文段**，并进入**同步已发送状态**。TCP 连接请求报文段的 首部中：
- **同步位 SYN** 设为 1，表明这是一个 TCP 连接请求报文段；
- **序号字段 seq** 设为初始值 x，它是 **TCP 客户进程**所选择的**初始序号** ；
    - 【注意】TCP 规定 SYN=1 的报文段不能携带数据，但要消耗（用掉）一个序号 seq ；
- ![tcpL04.png](/images/net/tcpL04.png "TCP-2客户进程")
- TCP 客户进程是主动发起，称为**主动打开连接**
<br/>

（三）TCP 服务器进程收到 TCP 连接请求报文段后，如果 <mark>同意建立连接</mark>，则向 TCP 客户进程发送 **TCP 连接请求确认报文段**，并进入**同步已接收状态**：
- **同步位 SYN** 和 **确认位 ACK** 都 = 1 ，表明这是一个 TCP 连接请求确认报文段；
- **序号字段 seq** 设为初始值 y，它是 **TCP 服务器**进程所选择的**初始序号**；
- **确认号字段 ack** 的值设置为 **x+1** ，它是对 TCP 客户进程选的初始序号（即：x）的确认（x+1 是 x+1 前的都确认的意思）；
- 【注意】这个报文段也不能携带数据（因为 SYN=1），同样消耗掉一个序号 seq ; 
- ![tcpL05.png](/images/net/tcpL05.png "TCP-3")
<br/>

（四）TCP 客户进程收到 TCP 连接请求确认报文段后，还要向 TCP 服务器进程发送一个**普通的 TCP 确认报文段**，并进入**连接已建立状态**；
- **确认位 ACK = 1** ，表明这是一个**普通的 TCP 确认报文段**；
- **序号字段 seq** 设置为 x+1，因为客户进程发的第一个 TCP 报文的 seq 序号为 x （下图黄色标出），而且**不携带数据（不消耗seq序号）**，因此如果接下来还发报文段，序号还是 x+1 ；
    - 【注意】TCP 规定普通的 TCP 确认报文段可以携带数据，也可以不带数据，**如果不带数据，不消耗序号**，下一个普通 TCP 报文段的序号 seq 和这个不带数据的 seq 可以一样；
- 确认号字段 ack 的值设置为 y+1 ，是对 TCP 服务进程所选择的初始序号（即：y）的确认（图中红色）  ；
- ![tcpL06.png](/images/net/tcpL06.png "TCP-4")
- 如图，红色 ack 值的来源对应红色 seq，黄色 seq 对应黄色 seq；
<br/>

（五）TCP 服务器进程收到 TCP 连接请求报文段后，也进入**连接已建立状态**（图中绿色状态），现在双方都进入了连接已建立状态，它们可以基于建立好的 TCP 连接进行可靠的数据传输了。
- ![tcpL07.png](/images/net/tcpL07.png "TCP-5")

### 为什么三次握手而不是两次？

现在问题来了：为什么最后还要发一个普通的 TCP 确认报文段呢？即为什么是三次握手而不是两次？两次握手能建立连接吗？——显然不可以，看这个例子：

1）客户进程发出 TCP 连接请求报文段 ，但这个报文滞留了，必然会造成**超时重传**。而重传的报文段则被正常接收了：
- ![tcpL08.png](/images/net/tcpL08.png "TCP两握手-1")
 
2）服务器进程给客户进程发一个 TCP 连接请求确认报文段 ，客户进程收到之后，双方都进入连接已建立状态，但不会回复确认（现在是两次握手）。现在它们可以传输数据，然后释放连接，双方都处于了关闭状态。
- ![tcpL09.png](/images/net/tcpL09.png "TCP两握手-2")
 
3）一段时间后，此前滞留的 TCP 连接请求报文段 到达了服务器进程。它会误以为这是客户进程 又发起的新 TCP 连接请求，于是回复了 TCP 连接请求确认报文段，并进入连接已建立状态。
- ![tcpL10.png](/images/net/tcpL10.png "TCP两握手-3")

4）但是客户端不会理会这个报文段，而服务器仍在 连接已建立状态，会以为新的连接已经建立好了，并一直等着客户进程发来数据，浪费主机的资源。

综上所述，使用三次握手而**不是两次，是为了防止已失效的连接请求报文段又传送到了 TCP 服务器**，因而导致错误。
- ![tcpL11.png](/images/net/tcpL11.png "TCP两握手-4")

-----------------

## - 8.2 TCP 的连接释放

TCP 通过**四报文挥手**来释放连接。

### TCP 四报文挥手的过程

现在，用户和服务器都处于连接已建立状态：
- ![tcpL12.png](/images/net/tcpL12.png "连接已建立")

（一）假设客户进程的应用进程通知其主动关闭 TCP 连接，客户进程发送 **TCP 连接释放报文段**，并进入**终止等待1状态**。
- **终止位 FIN 和确认位 ACK** 都 =1 ，表明这是一个 TCP 连接释放报文段，同时也对之前收到的报文段进行确认；
- **序号字段 seq** 设为 u ，**u = 客户进程之前已传送数据的最后一个字节的序号 +1** ；
    - 【注意】TCP 规定：终止位 FIN = 1 的报文段即使不携带数据，也要消耗掉一个序号 seq ;【后面有对应，在（四）】
- **确认号 ack 字段**的值设为 v ，**v = 客户进程之前已收到数据的最后一个字节的序号 +1** ；
- ![tcpL13.png](/images/net/tcpL13.png "发送 TCP 连接释放报文段")
</br>

（二）服务器进程收到 TCP连接释放报文段 后，会发送一个 **普通的TCP确认报文段**，并进入**关闭等待状态**。该报文段首部中：
- **确认位 ACK = 1** ，表明这是一个普通的 TCP 确认报文段；
- **序号字段 seq** = v ，**v = 服务器进程之前已传送过数据的最后一个字节的序号 +1** （与上面的确认号 ack 相匹配）；
- **确认号 ack 字段**设为 u+1，说明这是对 TCP 连接释放报文段的确认。
- ![tcpL14.png](/images/net/tcpL14.png "发送 普通的TCP确认报文段")

TCP 服务器进程此时应该通知其高层应用进程（享受TCP服务的进程）：客户进程要断开与自己的TCP连接。
- 此时**从客户进程到服务器进程的连接就释放/关闭了**，即：客户进程没有数据要发送了；
- 但如果服务器进程还有数据要发送，客户进程仍要接收；
- 即：**从服务器到客户的连接还未关闭**，现在是单向的数据传输；
- ![tcpL15.png](/images/net/tcpL15.png "只剩下单向了")

客户进程收到 TCP 确认报文后就进入**终止等待2**状态，等待服务器进程发出的 **TCP 连接释放报文段**。如果服务器进程已经没有数据要发送了（等上图紫色报文段完结），应用层进程就通知TCP服务器进程 释放连接。由于是客户进程发起的释放TCP连接，因此服务器进程对TCP连接的释放称为**被动关闭连接**。
- ![tcpL16.png](/images/net/tcpL16.png "终止等待2状态")

</br>

（三）TCP 服务器进程发送 **TCP 连接释放报文段**，并进入**最后确认状态**。该报文段首部中：
- **终止位 FIN 和确认位 ACK** 都 =1 ，表明这是一个 TCP 连接释放报文段，同时也对之前收到的报文段进行确认；
- **序号字段 seq** 设为 w ，因为在半关闭状态下，服务器进程可能又发送了一些数据（上图紫色报文段，从v到w）；
- **确认号 ack 字段**的值设为 u+1 ，这是对之前收到的 TCP 连接释放报文段 的重复确认
- ![tcpL17.png](/images/net/tcpL17.png "最后确认状态")
</br>

（四）客户进程收到 **TCP 连接释放报文段** 后，必须针对该报文段发送 **普通的TCP确认报文段**，然后进入**时间等待状态**。该报文段首部中：
- **确认位 ACK = 1** ，表明这是一个普通的 TCP 确认报文段；
- **序号字段 seq** = u+1 ，因为客户进程之前发送的 TCP 连接释放报文段虽然不携带数据，但要消耗掉一个序号；【对应（一）中对应伏笔】
- **确认号 ack 字段**设为 w+1，这是对所收到的 TCP 连接释放报文段的确认。
- ![tcpL18.png](/images/net/tcpL18.png "时间等待状态")
</br>

（五）服务器进程收到该报文段后进入**关闭状态**，而客户进程还要经过 **长为 2MSL 的时间等待状态** 后才能进入关闭状态（常为4分钟）。这完全是从工程上来考虑的
- MSL ：最长报文段寿命，建议为 2 分钟，也可根据情况使用更小的 MSL 值；
- ![tcpL19.png](/images/net/tcpL19.png "关闭状态")

### 客户服务器有必要等待再关闭吗？

问题又来了，必须要经过 2MSL 的时间等待再关闭吗？

现在假设：四报文中的最后一个报文 发出去了，客户进程立即就关闭状态：
- 如果最后的确认报文丢失了，服务器进程等不到确认势必要超时重传，并仍处于最后确认状态
- ![tcpL20.png](/images/net/tcpL20.png "如果直接关闭")
- 到达客户进程，但其已经处于关闭状态了，不会理睬该报文；

这必然导致服务器进程反复重传，并始终处于最后确认状态无法关闭；
- ![tcpL21.png](/images/net/tcpL21.png "无法关闭")

综上，时间等待状态以及处于该状态 2MSL 时长可以确保 **服务器进程能收到最后一个确认报文段而顺利进入关闭状态**。另外，经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，在下一个新的TCP连接中**不会出现旧连接中的报文段**。

### TCP 的保活计时器

最后，再看看TCP中**保活计时器**的作用。

现在，双方已经建立了连接，但客户进程所在的主机突然出现了故障。显然服务进程再也收不到客户进程发来的数据。因此有必要采取措施使 服务器进程**不要再白等下去**。
- ![tcpL22.png](/images/net/tcpL22.png "保活计时器-场景")

服务器进程如何发现这种情况呢？——保活计时器
- 服务器进程每收到一次  客户进程的数据，就重新设置并启动**保活计时器**（2小时定时）；
- 若保活计时器定时周期内**未收到** 客户进程发来的数据，则**保活计时器到时后，服务器进程就向客户进程发送一个探测报文段**，以后每隔 75 秒发一次。
    - 若一连10个报文段后，客户进程仍无响应，服务进程就可认为客户进程所在主机出现了故障，接着关闭这个连接。



-----------------
## 9. TCP 报文段的首部格式
