---
layout: post
title: "计网 Ch5：运输层 -2"
author: LJC
tags:
- network
date: 2022-11-02 11:20 +0800
toc: true
---

# 运输层 (Transport layer) - Part2

## 7. TCP 可靠传输的实现

TCP 基于**以字节为单位的滑动窗口**来实现可靠传输。

> 依然假定只在一个方向进行数据传输：一个发一个确认；并且，假定网络不存在拥塞问题【即发送窗口只考虑接收窗口即可，不用考虑拥塞窗口】

**TCP 可靠传输的实现流程：**

既然是以字节为单位，如图是待发送的字节序号以及接收方发来的确认字段，表明接收窗口宽度 20（发送窗口也设置成 20），31 以前的都确认无误，下一个希望收到 31。
- ![slide01.png](/images/net/slide01.png "SlidingWindow")

此时来看一下发送窗口：
- ![slide02.png](/images/net/slide02.png "SlidingWindow2")

发送窗口的**前沿和后沿**有以下可能的变化方式：
- ![slide03.png](/images/net/slide03.png "SlidingWindow3")

现在假设发送方把 31-41 的字节封装在几个报文段里发了出去（图中蓝色字节），而 41-50 是允许发送但还未发送的：
- ![slide04.png](/images/net/slide04.png "SlidingWindow4")

如何标记和维护滑动窗口的状态呢？—可以使用三个指针分别指向相应的字节序号，如下图：
- ![slide05.png](/images/net/slide05.png "SlidingWindow5")

再来看接收窗口（尺寸 20），假设封装有 32，33 号数据的报文段到达了接收方，由于在接收窗口内，所以接收了它们，并存入接收缓存（红色）。但是 31 还没到，因此它们是未按序到达的数据：可能丢失 / 或者滞留在网络中了：
- 由于接收方只能对按序收到的数据中的**最高序号**给出确认，因此确认报文中的确认序号仍然是 31 :
    - ![slide06.png](/images/net/slide06.png "SlidingWindow6")

发送方收到确认报文，发现这是对 31 号数据的**重复确认**，知道了接收方收到了未按序到达的数据。
- 由于这是对 31 号数据的**第一个重复确认**，并不会引起 发送方对 31 号数据 快重传（三个才重传）；

假设现在 31 号到达接收方了，交付给进程，然后接收窗口**前移三个**，并发送确认报文段，表明已经收到了 33 为止的全部字段，接下来想收到 34 了：
- ![slide07.png](/images/net/slide07.png "SlidingWindow7")

接下来又有几个未按序到达的数据，只能暂存在接收缓存中
- ![slide08.png](/images/net/slide08.png "SlidingWindow8")

发送方将发送窗口向前滑动三个序号，尺寸不变，可将 31-33 从缓存中删除。继续将 42-53 的数据封装在几个不同报文段发送出去，序号用完了，没有新的确认不会再发送了。
- 注意，已发送数据如果迟迟收不到确认，则会产生**超时重传**；
- ![slide09.png](/images/net/slide09.png "SlidingWindow9")

**注意事项：**
1. 虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，**发送方的发送窗口并不总是和接收方的接收窗口一样大**。
    - 因为传输窗口值的改变有一定的时间滞后，时间不确定。
    - 发送窗口还受**拥塞情况（拥塞窗口)**影响；
2. TCP 并**没规定对于不按序到达的数据的处理方法**
    - 如果直接丢弃不按序到达的数据，管理起来比较简单，但对网络资源利用不利，因为重传任务变多了；
    - TCP 通常对不按序到达的数据：临时存在接收窗口中，等**缺少的字节到达后，再按序交付给进程**；
3. TCP 要求接收方必须有**累积确认和捎带确认机制**，这样可以减小传输开销。接收方可以在合适的时候发送确认（推迟一会再确认），也可以在自己有数据要发送时捎带确认信息
    - 但是接收方不能过分推迟发送确认，这样导致不必要的超时重传，浪费网络资源
        -  TCP 规定推迟确认时间不能超过 0.5 秒，若收到一连串最大长度的报文段，则必须每隔一个报文段就发送一个确认。
    - 捎带确认机制实际上很少发生，因为大多数应用程序很少同时在两个方向上发送数据（全双工）
4. TCP 是**全双工通信**，每一方都既发送又接收，每方都有发送和接收窗口，【明确哪一方的哪个窗口】

-------------------

## 8. TCP 的运输连接管理

TCP 是面向连接的协议，基于运输连接来传送 TCP 报文段。
- **TCP 连接的建立和释放** 是每一次**面向连接**的通信必不可少的过程；
- TCP 运输连接有以下三个阶段：
    - ① 建立 TCP 连接：**三报文握手** ；
    - ② 数据传送：基于 TCP 连接，可靠传输；
    - ③ 释放 TCP 连接：**四报文挥手** ；
    - ![tcpL01.png](/images/net/tcpL01.png "TCP的运输连接管理-三部分")
-  TCP 的运输连接管理就是使运输连接的**建立和释放**都能正常运行；

## - 8.1 TCP 的连接建立 

TCP 的连接建立要解决以下三个问题：
1. 使 TCP 双方能感知到彼此存在；
2. 使 TCP 双方能**协商一些参数**（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等）；
3. 使 TCP 双方能够**对运输实体资源进行分配**（如缓存大小，连接表中的项目等）；

### TCP 使用三次握手建立连接的过程

如图，两个要基于 TCP 通信的主机，一台的进程主动发起 TCP 连接建立，称为 **TCP 客户**，另一台被动等待建立的进程称为 **TCP 服务器**。
- ![tcpL02.png](/images/net/tcpL02.png "TCP客户和服务器")

我们将 TCP 建立连接的过程比喻为“**握手**”，它**需要在客户和服务器之间交换三个 TCP 报文段**。

（一）最初，两端的 TCP 进程都处于关闭状态。做一些准备工作：
- TCP 服务器进程创建**传输控制块**，用来存储 TCP 连接中的一些重要信息；
    - 如 TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针等，如图；
- 此后准备接收 TCP 客户进程的连接请求，TCP 服务进程进入**监听状态**，等待连接请求。
- TCP 服务进程是被动等待，不是主动发起，称为**被动打开连接**
- TCP 客户进程也是首先创建传输控制块。
- ![tcpL03.png](/images/net/tcpL03.png "TCP-1服务进程")
<br/>

（二）TCP 客户进程在打算建立 TCP 连接时，向 TCP 服务器进程发送 **TCP 连接请求报文段**，并进入**同步已发送状态**。TCP 连接请求报文段的 首部中：
- **同步位 SYN** 设为 1，表明这是一个 TCP 连接请求报文段；
- **序号字段 seq** 设为初始值 x，它是 **TCP 客户进程**所选择的**初始序号** ；
    - 【注意】TCP 规定 SYN=1 的报文段不能携带数据，但要消耗（用掉）一个序号 seq ；
- ![tcpL04.png](/images/net/tcpL04.png "TCP-2客户进程")
- TCP 客户进程是主动发起，称为**主动打开连接**
<br/>

（三）TCP 服务器进程收到 TCP 连接请求报文段后，如果 <mark>同意建立连接</mark>，则向 TCP 客户进程发送 **TCP 连接请求确认报文段**，并进入**同步已接收状态**：
- **同步位 SYN** 和 **确认位 ACK** 都 = 1 ，表明这是一个 TCP 连接请求确认报文段；
- **序号字段 seq** 设为初始值 y，它是 **TCP 服务器**进程所选择的**初始序号**；
- **确认号字段 ack** 的值设置为 **x+1** ，它是对 TCP 客户进程选的初始序号（即：x）的确认（x+1 是 x+1 前的都确认的意思）；
- 【注意】这个报文段也不能携带数据（因为 SYN=1），同样消耗掉一个序号 seq ; 
- ![tcpL05.png](/images/net/tcpL05.png "TCP-3")
<br/>

（四）TCP 客户进程收到 TCP 连接请求确认报文段后，还要向 TCP 服务器进程发送一个**普通的 TCP 确认报文段**，并进入**连接已建立状态**；
- **确认位 ACK = 1** ，表明这是一个**普通的 TCP 确认报文段**；
- **序号字段 seq** 设置为 x+1，因为客户进程发的第一个 TCP 报文的 seq 序号为 x （下图黄色标出），而且**不携带数据（不消耗seq序号）**，因此如果接下来还发报文段，序号还是 x+1 ；
    - 【注意】TCP 规定普通的 TCP 确认报文段可以携带数据，也可以不带数据，**如果不带数据，不消耗序号**，下一个普通 TCP 报文段的序号 seq 和这个不带数据的 seq 可以一样；
- 确认号字段 ack 的值设置为 y+1 ，是对 TCP 服务进程所选择的初始序号（即：y）的确认（图中红色）  ；
- ![tcpL06.png](/images/net/tcpL06.png "TCP-4")
- 如图，红色 ack 值的来源对应红色 seq，黄色 seq 对应黄色 seq；
<br/>

（五）TCP 服务器进程收到 TCP 连接请求报文段后，也进入**连接已建立状态**（图中绿色状态），现在双方都进入了连接已建立状态，它们可以基于建立好的 TCP 连接进行可靠的数据传输了。
- ![tcpL07.png](/images/net/tcpL07.png "TCP-5")

### 为什么三次握手而不是两次？

现在问题来了：为什么最后还要发一个普通的 TCP 确认报文段呢？即为什么是三次握手而不是两次？两次握手能建立连接吗？——显然不可以，看这个例子：

1）客户进程发出 TCP 连接请求报文段 ，但这个报文滞留了，必然会造成**超时重传**。而重传的报文段则被正常接收了：
- ![tcpL08.png](/images/net/tcpL08.png "TCP两握手-1")
 
2）服务器进程给客户进程发一个 TCP 连接请求确认报文段 ，客户进程收到之后，双方都进入连接已建立状态，但不会回复确认（现在是两次握手）。现在它们可以传输数据，然后释放连接，双方都处于了关闭状态。
- ![tcpL09.png](/images/net/tcpL09.png "TCP两握手-2")
 
3）一段时间后，此前滞留的 TCP 连接请求报文段 到达了服务器进程。它会误以为这是客户进程 又发起的新 TCP 连接请求，于是回复了 TCP 连接请求确认报文段，并进入连接已建立状态。
- ![tcpL10.png](/images/net/tcpL10.png "TCP两握手-3")

4）但是客户端不会理会这个报文段，而服务器仍在 连接已建立状态，会以为新的连接已经建立好了，并一直等着客户进程发来数据，浪费主机的资源。

综上所述，使用三次握手而**不是两次，是为了防止已失效的连接请求报文段又传送到了 TCP 服务器**，因而导致错误。
- ![tcpL11.png](/images/net/tcpL11.png "TCP两握手-4")

-----------------

## - 8.2 TCP 的连接释放

-----------------
## 9. TCP 报文段的首部格式
