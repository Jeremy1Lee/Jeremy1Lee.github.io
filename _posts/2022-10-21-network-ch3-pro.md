---
layout: post
title: "计网（三）：数据链路层（纯享版）"
author: LJC
tags:
- network
date: 2022-10-22 13:30 +0800
toc: true
---

# 三、数据链路层 (Data link layer)

数据链路层，主要就干仨活：**封装成帧，差错检测，可靠传输**；

1. 封装成帧：帧头帧尾加控制信息。封装发送，解封阅读；
- 如何避免数据里也凑巧有帧头帧尾呢？- 加**转义字符**

2. **差错检测**：[CRC冗余校验算法](https://jeremy1lee.github.io/2022/10/21/network-ch3/#32-%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C-crc-cyclic-redundancy-check) ：除数，被除数，”除法“，异或，余数（补齐）。纠错能力强，异或对硬件友好。


3. **可靠传输**
 错已经检出来了，怎么可靠传输呢？- 肯定要重传了；
- 笨方法是一个一个（分组）地传【停止-等待】
    - 错一个（或超时）重发一个，对一个发下一个；
    - 再给他们编上号，避免分组重复
    - 显然利用率很低，时间都用来等信号往返了；
- 改进一下吧，我 n个 n个地传，对n个发下n个，错1个这n个全重发；【回退N帧协议/滑动窗口协议】
- 最后再改进一下，把发送和接收窗口全设置成 宽度和缓冲区大小关联的 滑动窗口【选择重传协议】

## [滑动窗口算法](https://baijiahao.baidu.com/s?id=1722866804266375910&wfr=spider&for=pc)的三方面意义

这里提到了一个重要算法：滑动窗口（回退N帧），计网里的滑动窗口算法也延伸到了Leetcode，有若干滑动窗口问题，可见这个算法的重要性。**滑动窗口**起两方面作用，一是窗口，二是滑动
- 一是窗口就这么大（N），每次发N个避免每次发一堆，接收方处理不过来，<u>窗口表示接收方目前能接收的缓冲区的剩余大小</u>；【流量控制】
- 二是每次把这N个整对了才往前滑动，不对就重发，实现可靠传输；【可靠传输】
- 三是所有结点都用上滑动窗口时，加入共同的拥塞窗口控制所有结点的滑动窗口大小，来共同改善全局网络情况；【拥塞控制】

单个结点不会有全局的网络通信情况，它只能控制它自己的流量【流量控制】，所有TDP结点都控制发送流量就能控制整个网络的拥塞【拥塞控制】，可以定义一个新的拥塞窗口来控制各结点的窗口大小。

- 对自己结点：实现**可靠传输**和**流量控制**；
- 对整个网络：实现**拥塞控制**



