---
layout: post
title: "操作系统-1"
author: LJC
tags:
- organization
date: 2022-11-05 15:10 +0800
toc: true
---

# 操作系统 Operating Systems

操作系统对解决很多工程问题提供了经典且有效的解决思路，在任务调度（多线程、并发），文件管理等等问题的解决方案和思路是典范性的。

------

## 什么是操作系统？

**操作系统是计算机硬件和应用之间的一层软件，使用计算机的硬件需要穿过操作系统**，如果再装一些软件就更方便/高效使用了。操作系统让我们使用硬件更加方便。

![os01.png](/images/os/os01.png "操作系统的作用/位置")

OS 管理哪些硬件？主要讲这些基本部分：

![os02.png](/images/os/os02.png "操作系统管理哪些硬件")

学习的层次：
- 只知道接口，只会调用，但不知道其内部的深层次：
    - ![os03.png](/images/os/os03.png "学习的层次1")

- 知道操作系统的细节，背后发生的事情，进程怎么实现？为什么可以管理CPU？fork做了什么事？改动操作系统；
    - ![os03-1.png](/images/os/os03-1.png "学习的层次2")

- 搭建操作系统
    - ![os03-2.png](/images/os/os03-2.png "学习的层次3")

学习目标：能改操作系统，知道操作系统**如何运转**，Learning OS concepts by coding them！在原理和代码之间频繁切换。

-------------------

> 计算机的工作原理：**取指-执行**

使用计算机硬件，要用操作系统为我们提供的接口来使用，方便使用计算机，提高效率。比如有了printf我们使用计算机就不用一个一个显示了。

计算机是怎么工作的？其实是在一个模型下设计出来实现。

- 1936 的图灵机：借鉴了人-笔-纸：看到1+2，在脑子里找到规则，得到5，写下来；用自动设备模拟，如纸带；
    - ![os04.png](/images/os/os04.png "图灵机")
    - 图灵机只会加法（取决于它的控制器）

- 通用图灵机：控制器可变—— 根据读取的逻辑 先设置控制器动作，然后操作数据对象；逻辑给加法就是加法，给减法就是减法。
    - ![os05.png](/images/os/os05.png "通用图灵机")
    - 显然，这个设置控制器动作的过程，和 程序 很像。

- 1946的 冯 · 诺依曼**存储程序思想**：将程序和数据存放到计算机内部的存储器中，计算机在程序的控制下一步一步进行处理：
    - 可以看到，<mark>程序（指令）存到计算机内存里，然后用一个**指针**指向它，然后取指，CPU（控制器）解释程序，并按照指令执行，产生结果</mark>；
    - 计算机执行的过程就是四个字：**取指-执行**；
    - ![os06.png](/images/os/os06.png "冯 · 诺依曼")

-------

### 回顾操作系统的发展历史

- 1940s：没有操作系统，能把程序放上去就很了不起了，程序直接用指令操作硬件，不需要程序来画蛇添足，不过可以完成弹道等复杂的计算。
<br/>

- 1950s：出现了更快更小的逻辑门，更大的内存，丰富的 I/O 设备
    - **I/O设备的速度严重低于处理器速度**（后来的并发）（Fortran：程序是在卡片上面打孔），**中断**机制出现；
    - 操作系统管理多个程序一次排队运行的库函数和调度器；
    - 操作系统的概念开始形成：
        - 操作(operate) 任务(jobs) 的系统(system)
            - **批处理系统** = 程序的自动切换 + 库函数 API，即一个程序执行完了再执行下一个，下一个.....
            - **Disk Operating Systems （DOS）**
                - 操作系统中开始出现 设备，文件，任务 等对象和 API ，把一些程序结果存到文件里；
                <br/>
- 1960s：集成电路，总线出现
    - 更快的处理器，**更快更大的内存**：虚拟存储出现
        - 可以把好几个程序同时放到内存里，而不用“换卡”了；
        - 比如这个程序： cpu（30s）→ 打印机（5分钟），在打印机的时间段内可以让cpu干别的；
    - 更丰富的 i/o设备，完善的 中断/异常机制
    - 更多高级语言和编译器出现
- 1960s 的操作系统：能**同时载入多个程序到内存**，且灵活调度（两个程序交替运行）
    - 有了**进程（process）**的概念；
        - 进程执行 I/O时，可以将 CPU 让给另一个进程
            - 在多个地址空间隔离的程序之间切换
            - 一个程序 出bug，不会 crash 整个系统；
                - ![osHisT01.png](/images/os/osHisT01.png "基于中断的调度")
    - 既然操作系统可以在程序之间切换，再让它们**定时切换**：
        - 基于中断（例如时钟）机制：
        - 时钟中断：异步插入函数调用；
        - 由操作系统（调度策略）决定是否切换到另一个程序执行；
        - **Multics**：分时，现代操作系统诞生；
        <br/>

- 1970s 的操作系统：
    - CISC 指令集；中断，I/O，异常，MMU，网络
        - 个人计算机（PC），超算....
        - **今天计算机能办到的，1970s 就已经能办了**；
    - UNIX 诞生并完善，奠定了现代操作系统的形态；
        - 1983：socket（对象）
        - procfs（对象）
        - UNIX 衍生的大家族：GNU (1983)，MacOS (1984)，Windows (1985)，Linux (1991)，XP (2002)，Ubuntu (2004)，IOS (2007)，Android (2008)，Win 10 (2015)
<br/>

- 今天的操作系统：
    - **虚拟化 硬件资源**，为程序提供服务的软件；
    - 更复杂的处理器和内存
        - 12Gen P/E-cores大小核调度；
        - 更多更多的硬件机制（插拔进出）
    - 更多的设备和资源：网卡，SSD，GPU，FPGA...
    - 复杂的应用需求和环境：服务器，PC，手机手表手环...

--------------

### 理解操作系统：三个根本问题

操作系统服务谁？
- **程序 = 状态机**；

操作系统为程序提供什么服务？
- **程序视角：操作系统 = 对象 + API** ；

如何实现操作系统提供的服务？
- **硬件视角：操作系统 = 一个 C 程序**，完成初始化后就称为 interrupt/ trap/ fault handler ；

如何进步？—— 使用命令行-PowerUser，以及Google；并且写更多的代码！

---------------------------------

### Getting Started With Linux

- 工具： tldr (Too long, Don't read) 项目
    - man (manual)太长了，且无高亮，不想读
    - Usage: tldr command [options]


-----------------------------








