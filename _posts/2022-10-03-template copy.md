---
layout: post
title: "多路查找树"
author: LJC
tags:
- Java
- Tree
date: 2022-10-07 22:00 +0800
toc: true
---

## 二叉树与多叉树

### 二叉树存在的问题：高度太大，效率降低

二叉树需要加载到内存。如果二叉树节点少，没什么问题。但如果节点很多（1亿）就存在如下问题：

- 1）在构建二叉树时，需要**多次 i/o 操作**（节点可能来自文件，或数据库），构建速度有影响；

- 2）节点海量，也会造成二叉树的高度很高（即使是完美二叉树 2^n - 1 个对应 n 层），降低操作速度；

根本原因在于：**二叉树只有左子节点和右子节点！而且一个节点一个数据域！**

### 多叉树

二叉树每个节点有数据项，最多有两个节点。如果**允许每个节点有更多的数据项和更多的子节点**，就是多叉树；例如：2-3 树，2-3-4 树就是多叉树。通过重新组织节点，减少树的高度，能对二叉树进行优化。例如：

![multiTree.png](/images/multiTree.png "多叉树"){: .align-center}

## B 树

B 树通过重新组织节点，降低树的高度，并且减少 i/o 读写次数来提升效率。图中的 o-o-o 都是节点，只是**一个节点存放多个数据项**，一个圆圈表示一个数据项，相连的数据项，整个表示一个节点，如黄色部分。 

![bTree.png](/images/bTree.png "B树"){: .align-center}

- B 树的优点是多的数据项减少了节点数量，降低树的高度。

- 文件系统及数据库系统的设计者利用了**磁盘预读原理**（预先读取数据），如果将一个节点的大小设为等于一个页（通常大小为 4K）

- 将树的度 M 设置为 1024 ，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素。B 树（B+ ）广泛应用于文件存储系统以及数据库系统中。可以在一个文档里快速找到数据。如：索引基于 B 树/ B+ 树

> 节点的度：一个节点的子节点个数。树的度：所有的节点里度最大的值（子节点最多）；

## 2-3 树

### 介绍

2-3 树是最简单的 B 树结构，具有如下特点：

- 2-3树的所有**叶子节点都在同一层**（只要是 B 树，都满足这个条件），也就是完美二叉树/满树/2^n - 1 个对应 n 层；

- 二节点：**要么有两个子节点，要么没有子节点**的节点；

- 三节点：**要么有三个子节点，要么没有子节点**的节点；

- 2-3 树是由**二节点**和**三节点**构成的树；

&emsp;&emsp;思考：既然是完美二叉树，非叶子肯定满节点（2/3），叶子肯定没节点，与上面的性质一道，这些特点也决定了如何构建 2-3 树。

### 构建 2-3 树

> 将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20}构建成 2-3 树，并保证数据插入的大小顺序。
 
保证大小顺序，即仍然要满足排序树 (BST) 的特点：左 > 自己 > 右 （二节点）；左子 > 自己数据1 > 中子 > 自己数据2 > 右子 （三节点）；

2-3 树的构建示意图：

![23tree01.png](/images/23tree01.png "1"){: .align-center}

![23tree02.png](/images/23tree02.png "2"){: .align-center}

注意这里看起来挤 24 上去也可以，但此时三节点的两个数据为 [16,24] ，那么没有对应的中子节点了，不符合规则，所以把 26 挤上去，让 24 成为中子节点，满足三节点有三个子节点。

![23tree03.png](/images/23tree03.png "3"){: .align-center}

添加 10 是最复杂的。因为父节点 [16, 26] 也满了，所以 [10, 12, 14] 这三个只能成为子树了，为了保证叶子节点同层，只能再从父节点拉下来一个节点多出一层，满足规则。

![23tree04.png](/images/23tree04.png "4"){: .align-center}


{% highlight js %}
3
{% endhighlight %}
