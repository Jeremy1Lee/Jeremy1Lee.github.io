---
layout: post
title: "堆排序(图解)"
author: LJC
tags:
- Java
date: 2022-09-27 10:35 +0800
toc: true
---

> 既然数组与树一一对应，那么一个数组也可以看成树，利用**树结构**来分治、排序。

## 树、堆的相关概念

- 二叉树

树的形状影响了其性质。树按形状不同可以分为：完满(full)二叉树、完全(complete)二叉树、完美(perfect)二叉树，如图所示：
![binaryTree01.png](/images/binaryTree01.png "Tree"){: .align-center}

- 堆

另一重要的概念是**大顶堆和小顶堆**，以及二叉树的顺序存储结构
![heap01.png](/images/heap01.png "Heap"){: .align-center}

## 堆排序的流程

堆排序可以理解为选择排序的升级版，选排是遍历全部选最值，堆排是分治选局部最值，最终选出全局最值。部分的划分又和**希尔排序**比较像，都是局部收敛最终达到全局收敛。堆排序的流程如下：

1. 将无序序列构造成一个**大/小顶堆**，此时序列的最大/小值就是堆顶（root节点）
2. 将堆顶元素与末尾元素交换，此时末尾成为最大/小值
3. 将剩余n-1个元素重新构造成堆，继续在堆顶得到这n个元素的次大/小值
4. 反复构建堆并交换，直到堆中无元素，此时序列达到有序

这里我们看到，现有数组不同，对应的堆也不同，可见堆是要**维护**的。

### 图解堆排序流程

我们全程都是对数组下标操作，没有把数组转换成对应的树，下图列出了堆排序时数组和对应的树是如何变化的：

![adHeap01.png](/images/adHeap01.png "adHeap02"){: .align-center}
对于节点6，寻找是否子节点大于6，若有，则与子节点交换。然后对上层节点4同样进行此过程，4与9交换。注意这时下来的4却小于其子节点5、6，要进一步交换到底。由此我们可以看出：<mark>对于每个节点的维护都要一直检查到底</mark>。

![adHeap02.png](/images/adHeap02.png "adHeap01"){: .align-center}
最后的根节点则为最值，与末尾值交换，并不再参与堆的维护，这样一次维护就完成了。
接下来以此类推，直到堆中只剩一个元素。

何时结束？

**从左到右，从下到上**调整。完全循环就可以搞定



## 代码实现堆排序


代码分成两部分：维护/更新堆，取出最值，以此类推。维护堆的方法由**构造大/小顶堆的方法+执行方法的顺序**构成，代码的核心是维护大/小顶堆的*adjustMaxRootHeap*方法。

### （一）维护堆的方法

执行方法的图解如下图所示。

![adHeap05.png](/images/adHeap05.png "adHeap05"){: .align-center}

每个节点都要执行该方法，并且要从该节点开始，直到树尾对值进行搜索。搜索的过程如下图：
i为父节点索引，k是i的子节点中较大节点的索引，如果arr[i] < arr[k]，就交换这两个值，然后i要从子节点k开始，继续往下寻找。

何时停止向下寻找(break)？如图，有两种情况：
![adHeap03.png](/images/adHeap03.png "adHeap03"){: .align-center}
- 一是迭代后的k>length(左)，这表明已经超出数组了。btw，length的作用是在找到一次最大值后-1，控制循环次数；

- 二是对于某个父节点而言，其子节点都比它小，无需交换(右)。由于整体是从下至上，下面已经是排好的大顶子堆，所以无需再向下搜索了；

方法代码如下：
![adHeap04.png](/images/adHeap04.png "adHeap04"){: .align-center}

### （二）执行方法的顺序

- 每个节点都要向下有序

![d01.png](/images/d01.png "流程"){: .align-center}

如图，对8来说以8为根的子树(蓝色)必须是一个大顶堆，这需要通过*adjustMaxRootHeap*方法实现。由于单一节点(最底层)不存在排序的需要，所以对于第一梯队而言很容易完成排序，完成以8为根的大顶堆是基于以6为根的子大顶堆前提的，上面*Heap*方法也提到了这一点。

> 在每层可以考虑用其他排序算法排好序，这样似乎也可以排好整个数组。

基于上述原理，只调用一次*adjustMaxRootHeap*方法显然不能找到全局最值。虽然一次*adjustMaxRootHeap*完成从输入节点到底的max堆，但是并没有达成**输入节点的子树都有序的**这一前提，因此我们需要多次调用*adjustMaxRootHeap*方法。

- 对树的每个层而言，要从下层往上层操作(第一梯队->第二梯队->第三梯队->第四梯队)

可以把树想象成金字塔，先把根基（最底层）排好序，再完成建筑（上层），最后到达顶端。注意，此时的大顶堆转换成数组并不是排好序的，因为对某节点来说，它的左节点可能大于右节点，方法是不对左右子节点进行排序的。就算加入了左右子节点排序，对同一层、不同节点的左右节点也无法做到完全有序。

总之，在每层中**从左到右**执行方法（蓝色箭头方向），在方法中**从父节点到子节点**（黄色箭头方向），整体则是**从下层到上层**（红色箭头）。

按图示来说，即先红1:{节点6(6和2，4比较)-节点4-节点3-节点5}再红2，红2中先蓝1(i -> k -> j)，再蓝2，以此类推，直到节点15执行最后一次*adjustMaxRootHeap*方法。其中蓝色是*adjustMaxRootHeap*方法的作用域，红色是层，黄色是方法中的父子节点。

- 完成下至上的层排序后，根节点即为当前length下的最值
将根节点的值与数组最后一个值（树尾）交换，然后**length-1**，此时在方法中不会再涉及该最值，退出循环的条件为length=1。
