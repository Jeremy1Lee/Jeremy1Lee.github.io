---
layout: post
title: "堆排序(图解)"
author: LJC
tags:
- Java
- Algorithm
date: 2022-09-27 10:35 +0800
toc: true
---

> 既然数组与树一一对应，那么一个数组也可以看成树，利用**树结构**来分治、排序。

## 树、堆的相关概念
 
- 二叉树

&emsp;&emsp;树的形状影响了其性质。树按形状不同可以分为：完满(full)二叉树、完全(complete)二叉树、完美(perfect)二叉树，如图所示：
![binaryTree01.png](/images/binaryTree01.png "Tree"){: .align-center}
 
- 堆

&emsp;&emsp;另一重要的概念是**大顶堆和小顶堆**，以及二叉树的顺序存储结构
![heap01.png](/images/heap01.png "Heap"){: .align-center}

## 堆排序的流程

&emsp;&emsp;堆排序可以理解为选择排序的升级版，选排是遍历全部选最值，堆排是分治选局部最值，最终选出全局最值。部分的划分又和**希尔排序**比较像，都是局部收敛最终达到全局收敛。堆排序的流程如下：

1. 将无序序列构造成一个**大/小顶堆**，此时序列的最大/小值就是堆顶（root节点）
2. 将堆顶元素与末尾元素交换，此时末尾成为最大/小值
3. 将剩余n-1个元素重新构造成堆，继续在堆顶得到这n个元素的次大/小值
4. 反复构建堆并交换，直到堆中无元素，此时序列达到有序

这里我们看到，现有数组不同，对应的堆也不同，可见堆是要**维护**的，在维护之前，要先建立大顶堆。

### 图解堆排序流程

&emsp;&emsp;我们全程都是对数组下标操作，没有把数组转换成对应的树，下图列出了堆排序时数组和对应的树是如何变化的：

![adHeap01.png](/images/adHeap01.png "adHeap02"){: .align-center}
&emsp;&emsp;对于节点6，寻找是否子节点大于6，若有，则与子节点交换。然后对上层节点4同样进行此过程，4与9交换。注意这时下来的4却小于其子节点5、6，要进一步交换到底。由此我们可以看出：<mark>对于每个节点的维护都要一直检查到底</mark>。

![adHeap02.png](/images/adHeap02.png "adHeap01"){: .align-center}
&emsp;&emsp;最后的根节点则为最值，与末尾值交换，并不再参与堆的维护，这样一次维护就完成了。接下来以此类推，直到堆中只剩一个元素，最后得到有序数组。

## 代码实现堆排序

&emsp;&emsp;代码分成两部分：建立-更新堆、取出最值，并以此类推。维护堆的方法由**构造大/小顶堆的方法+执行顺序**构成，核心是维护堆并求最值的*adjustMaxRootHeap*方法。

### （一）建立堆的方法

&emsp;&emsp;为了建立堆，每个父节点都要执行该方法，**从自己开始直到树尾**进行搜索。过程如下：
![adHeap05.png](/images/adHeap05.png "adHeap05"){: .align-center}
&emsp;&emsp;i为父节点索引，k是i的子节点中**数值较大节点**的索引，如果 **arr[i] < arr[k]**，交换这两个值，然后i迭代成子节点k，以继续向下搜索。

&emsp;&emsp;何时停止向下寻找(break)？有两种情况如下图：
![adHeap03.png](/images/adHeap03.png "adHeap03"){: .align-center}
1. 迭代后，**k>length** (左)，这表明当前索引已经超出数组长了。BTW，**length**的作用是在找到一次最大值后-1，控制循环次数的同时减少重复遍历；

2. 对于某个父节点而言，如果子节点都比它小，则无需交换(右)。由于整体执行方法的顺序是从下至上，而下面已经是排好的子堆，所以无需再进行了，break；

&emsp;&emsp;全部代码如下：
![adHeap04.png](/images/adHeap04.png "adHeap04"){: .align-center}

### （二）执行方法的顺序

执行顺序：从最后一个非叶子节点开始，索引每次-1，直到堆顶也执行完，大顶堆就建立起来了。关于执行的顺序，有以下要点：

- 每个节点都要向下有序

&emsp;&emsp;如图，对8来说，以8为根节点的子树(蓝色)必须是一个大顶堆，通过执行*adjustMaxRootHeap*方法实现。由于单一节点(最底层)不需要排序，所以对于第一梯队（如6）而言只有两个子节点，容易完成排序。在节点6完成堆维护后，以8为根的大顶堆才有了以6为根的子堆作为前提执行方法，上面*Heap*方法中关于何时*break*也提到了这一点。

&emsp;&emsp;因此，只调用一次*adjustMaxRootHeap*方法显然不能找到全局最值。虽然一次*adjustMaxRootHeap*完成从输入节点到树底的维护，但是并没有达成“**输入节点的子树都有序**”这一前提，再一次强调了每个父节点都要调用*adjustMaxRootHeap*方法。

![d01.png](/images/d01.png "流程"){: .align-center}

- 对树的每层而言，要由下层向上层操作(第一梯队->第二梯队->第三梯队->第四梯队)

&emsp;&emsp;可以把树想象成金字塔，先把根基（最底层）排好序，再完成建筑（上层），最后到达塔尖（根）。注意，此时的大顶堆所对应的数组并不是**完全**排好序的，因为: 1) 对某节点来说，它的左节点可能大于右节点，方法是不对左右子节点进行排序的（图中节点4）。2) 就算在方法中把左右子节点排好序，对同一层的不同节点，其左右节点也无法做到完全有序（图中节点6和节点5及子节点）。

&emsp;&emsp;总之，在每层中**从左到右**执行方法（蓝色箭头方向），在方法中**从父节点到子节点**（黄色箭头方向），整体则是**从下层到上层**（红色箭头）。

&emsp;&emsp;按图示而言，蓝色是*adjustMaxRootHeap*方法的作用域，红色是树层，黄色是*Heap*方法中的父子节点。执行顺序应该是先红1中的节点5:{节点5(2和0比较)-节点3-节点4-节点6}再红2，红2中先节点7，即蓝1(i -> k -> j向下顺序)，再节点8(蓝2)，以此类推，直到节点15执行完最后一次*adjustMaxRootHeap*方法后，堆顶则为最值。**大方向**指方法调用的顺序(从节点5的索引依次-1)，**小方向**指每次方法中节点迭代的顺序(从输入节点到其子节点，再到子子节点...)

&emsp;&emsp;完成从右到左，从下至上的层排序后，根节点即为**当前**length下的最值。将根节点的值与数组最后一个值（树尾）交换，并**length--**，后面不会再涉及该最值，退出循环的条件为length=1。

### （三）方法重载与排序主体

&emsp;&emsp;在执行方法前，要明确从哪个节点开始执行？以及如何循环到顶？由于堆排序基于完全二叉树，有性质：索引为i的节点的子节点分别为2i+1和2i+2。另外我们知道最后一个叶子节点索引是n-1（n为array.length），同时**最后一个叶子节点的父节点就是最后一个非叶子节点**。基于完全二叉树，只有如下两种情况：

![final01.png](/images/final01.png "非叶子节点"){: .align-center}

- 最后一个非叶子节点只有左孩子节点（图1）

&emsp;&emsp;此时最后一个节点索引为n-1，其父节点索引为i，有：**2i+1=n-1, i=n/2-1**。

- 最后一个非叶子节点有左右两个节点（图2）

&emsp;&emsp;此时最后一个节点索引为n-1，其父节点索引为i，有：**2i+2=i-1, i=n/2-3/2 = n/2-1**。
&emsp;&emsp;综上，最后一个非叶子节点的索引为**n/2-1，n为数组长度**，完整的建立大顶堆代码为：

{% highlight js %}
    // 多次执行Heap方法，建立大顶堆
    for (int i = arr.length/2-1; i>=0;i--){
            adjustMaxRootHeap(arr,i, arr.length);
        }
{% endhighlight %}

&emsp;&emsp;接下来由于交换了堆顶和末尾元素，只改了堆顶的值，下面仍然是有序的。现在由于元素的交换，需要**维护堆**。只要执行**一次**开始元素为树顶 0 的*adjustMaxRootHeap*方法即可。不明白为什么只需要一次方法的话，这里和上面循环建立大顶堆时的最后一步是类似的，只是堆内元素减少了。

{% highlight js %}
    // 多次维护大顶堆
    for (int j = arr.length-1; j>0; j--){
        // 循环到元素全部有序为止，每次堆里元素-1
        temp = arr[j];
        arr[j] = arr[0];
        arr[0] = temp;
        // 已有大顶堆，且只改变堆顶，只需要一次从头到底的更新即可
        adjustMaxRootHeap(arr, 0, j);
    }
{% endhighlight %}

## 堆排序总结

&emsp;&emsp;整个堆排序的流程图如图所示：

![chart01.png](/images/chart01.png "流程图"){: .align-center}

- 堆排序速度非常快
- 时间复杂度为O(nlogn)，线性对数阶；不稳定排序
- 一些适用场景：一万个数，如何快速找到其中最大的10个？

&emsp;&emsp;——维护一个容量为10的小顶堆，每次进来一个数和小顶堆的堆顶（最小的）比较，如果大于堆顶，进堆。