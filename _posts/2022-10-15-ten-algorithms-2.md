---
layout: post
title: "常用十种算法（二）"
author: LJC
tags:
- Data Structure and Algorithm
date: 2022-10-15 21:10 +0800
toc: true
---
将数据结构使用到实际场景，解决一个问题，重点在于算法。（2）
{: .message }

## 六、普里姆 (Prim) 算法 - 最小生成树

应用场景：修路问题-最小生成树

有 7 个村庄 (A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通，各个 **村庄的距离用边线表示(权)**，比如 A – B 距离 5 公里。如何修路保证各个村庄都能连通，并且**修建公路 总里程最短**?

思路：只满足连通的话，将 10 个点全连上就行了，但总的里程数肯定不是最小。满足连通，又保证总里程最短的思路：尽可能少修路，如果不得不修，也要修短的路，保证总里程数最少。

![mst01.png](/images/mst01.png "MST"){: .align-center}

### 最小生成树：由图到树

修路问题的本质/建模，就是最小生成树问题。最小生成树 (Minimum Cost Spanning Tree)，简称 **MST**。给定一个**带权的无向连通图**，如何选取一棵生成树，使树上所有边上权的总和为最小，这叫最小生成树 ，它有如下特点：

-  N 个顶点，一定有 N - 1 条边（如右图考虑了一种最最简陋的连接方式）

- 包含全部顶点（所有节点都可达）

- 树的 N-1 条边都在图中

求最小生成树的算法主要是 **普里姆算法** 和 **克鲁斯卡尔算法**。既然是由图到的树，而且图（多对多）更符合现实，这表明和其他树结构比，其应用范围更广。

### 普利姆 (Prim) 算法

普利姆（Prim）算法求最小生成树，也就是：在包含 n 个顶点的连通图中，找出只有 (n-1) 条边包含所有 n 个顶点的连通子图，也就是所谓的**极小连通子图**。

1. 设：
- G=(V,E) 是连通网Graph；
- T=(U,D) 是最小生成树Tree；
- V、U 是顶点集合；
- E、D 是边的集合；

2. 若从顶点 u 开始构造最小生成树，则从集合 V 中取出顶点 u 放入集合 U 中，标记顶点 v 的 <mark>visited[u]=1</mark> ，表示已经访问过。

3. 若集合 U 中顶点 ui 与集合 V-U 中的顶点 vj 之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点 vj 加入集合U中，将边（ui,vj）加入集合 D 中，标记 <mark>visited[vj]=1</mark>。

4. 重复 **2**，直到 U 与 V 相等，即所有顶点都访问一遍（被标记过），此时 D 中有 n-1 条边，结束。

图解如下：

![prim01.png](/images/prim01.png "Prim Algorithm"){: .align-center}

代码实现：不连通的顶点用一个很大的数表示（这里是10000）。用到的数据结构：visited[ ] 表示是否访问过，把顶点分成两个集合，对 int[ ][ ] weight 作条件判断：只有起点 i 未访问且终点 j 访问过，才考虑这个边（图中黑色加粗的边），每次更新且重置的 minWeight 找到最短边，并把终点 j 标记为已访问。核心代码如下，很好理解：

{% highlight js %}
// 1. 当前节点标记为已访问
vertexVisited[startVertex] = 1;

        // 2. 直到生成 n-1 个边停止
        for (int k = 1; k < graph.verx; k++) {
            // 对目前每个节点，找它们连着的最短节点
            for (int i =0;i<graph.verx ;i++){
                for (int j = 0;j<graph.verx;j++){
                    // 起点i是访问过的节点，终点j是没访问过的节点，条件是最短，初始是10000，第一次也照顾到了
                    if (vertexVisited[i] == 1 && vertexVisited[j] ==0 && graph.weight[i][j] < minWeight){
                        minWeight = graph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            System.out.println("第 "+k+" 轮找到的边：由 "+graph.data[h1]+" 到 "+graph.data[h2]+" ，权值为"+minWeight);
            vertexVisited[h2] = 1;
            sumWeight += minWeight;
            minWeight = 10000; // 重置minWeight
        }
{% endhighlight %}

## 七、克鲁斯卡尔 (Kruskal) 算法 - 最小生成树

应用场景：公交站问题-最小生成树

某城市新增 7 个站点(A, B, C, D, E, F, G) ，现在 需要修路把 7 个站点连通，各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里 问：如何修路保证 各个站点都能连通，并且 总的修建公路总里程最短？ 模型本质和上面的问题一样，只是换了数值。

克鲁斯卡尔 (Kruskal) 算法，是用来求加权连通图的最小生成树的算法。n 个站点仍然是 n-1 条边，这没有变，Kruskal的基本思想是：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路。即：首先构造一个只含 n 个顶点的森林；然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止；

![kruskal01.png](/images/kruskal01.png "Kruskal Algorithm"){: .align-center}

对于如图所示的连通网，可以有多棵权值总和不同的生成树。显然连通方式有很多，但是哪一种权值才是最优的呢？下面是克鲁斯卡尔算法的图解步骤：以数组 R 保存最小生成树结果。

两条核心做法是：**1）对边的权值排序，2）加入森林并判断回路**。排序的话，8 种排序可以使用，如何判断回路才是难点。**判断回路的方式**：记录顶点在**最小生成树**中的终点，顶点的终点是 在最小生成树中与它连通的最大顶点。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。图解如下：

![kruskal02.png](/images/kruskal02.png "判断回路"){: .align-center}

<mark>终点</mark> ：将所有顶点按照加入顺序排列好之后；某个顶点的终点就是此时加入顺序中 与它连通的最大顶点。如左图，将三条边 E,F  C,D  D,E 加入最小生成树 R 之后，顶点 C, D, E, F 的终点都是 F 。

因此，接下来，虽然 边 <C, E> (5) 权值最小，但 C 和 E 的终点都是 F，即它们的终点相同，因此，将 <C, E> 加入最小生成树的话，会形成回路，C和F，C和D同理。这就是判断回路的方式。也就是说，**待加入边的两个顶点不能都指向同一个终点**，否则将构成回路。

### 代码实现

这部分是代码的核心：写一个方法，输入顶点 i ，返回其终点下标：

![kruskal03.png](/images/kruskal03.png "判断回路的代码实现"){: .align-center}

首先注意：**边的起点和终点指的是有向矢量的起始和箭头指向点**，而**顶点的终点指的是防止回路的那个人为定义的边结束点**。这段代码的意义就是按照图中红色箭头顺序寻找终点的过程，怎么实现的呢？在加入边后为每一个新增边的起点指派终点：如图所示：

- 【新增边的起点】的【终点】是【新增边的终点】；

- 【新增边的终点】的【终点】是【0】；

当查询时，就一直找这个点的终点，直到哪个点的终点是0了，那它就是有关联，且最新增的边的终点。查询时具体是：如果一个边还没加入结果集合，其两个顶点的终点都是 0 。所以，如果 ends[i] != 0，那么循环让<mark> i = ends[i];</mark>，由于在取边时的赋值操作，ends数组会循环到第一个ends为0的顶点，并返回此顶点。如右图，DE边加入后，如果再想加入FD，肯定要先判断D和F的终点。 D 在找终点 getends[D] 时，会循环： i = ends[ i ] ：

-  i0 = D, ends[i0] = ends[D] = E；
-  i1 = E, ends[i1] = ends[E] = F ；
-  i2 = F, ends[i2] = ends[F] = 0，退出循环，返回i2，即F；

这表明 D 的终点是 F 。

### 流程图

整个 Kruskal 算法的流程图如下：

![flowChart06.png](/images/flowChart06.png "flowChart-Kruskal"){: .align-center}

## 八、迪杰斯特拉 (Dijkstra) 算法 - 某一起点的最短路径

应用场景：最短路径问题

有 7 个村庄 (A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄，各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里。问：如何计算出 G 村庄到 其它各个村庄的 最短距离? 如果从其它点出发到各个点的最短距离又是多少？即：某个点出发，到另一个点的最短距离。显然 G - A 是直达，很简单，但 C - D 就不好说了。问题还是很有实际意义的，比如坐地铁算出最短路径等。

迪杰斯特拉（Dijkstra）算法是典型的最短路径算法，用于 计算一个结点到其他结点的最短路径。 它的主要特点是 **以起始点为中心向外层层扩展 (广度优先搜索思想)**，直到扩展到终点为止。由于 BFS 是一层一层计算，所以会反映本层到下一层的最短路径。

### 算法流程

用到了三个数组：V记录顶点, dis记录距离，还有记录前驱的数组。设：

- **v**：出发顶点

- **V**：为顶点集合 V { v1,v2, ... , vi }

- **dis**：出发点 v 到 V 中其他各个顶点的距离 dis{ d1,d2, ... , di }。到自身（v 到 v）的距离为 0，v 到 Vi 的距离为 di

算法过程如下：

1. 从 dis 中选择值最小的 di 并移出 dis 集合，同时移除 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径；
2. 更新 dis 集合，更新规则为：比较【v 到 V 集合中顶点的距离】与 【v 通过 vi 到 V 集合中顶点的距离值】，保留较小的一个（同时也应该更新顶点的 前驱节点 为 vi，表明是通过 vi 达到的v。）
3. 重复执行两步骤，直到最短路径顶点为目标顶点即可结束；

为什么要有前驱结点？因为当前的道路不一定最短，随时调整，回溯。知道了前驱就能调整访问结点的顺序。比如从 G 点出发，会访问 G,A、G,B、G,E、G,F，那么 A、B、E、F 的前驱节点就是 G。 dis 数组记录**当前从起点到其他所有顶点的最短距离**，Dij算法就是不停动态更新这三个数组，得到最终结果。最重要的是 dis 数组，通过不停**维护 dis 数组**，保证每次加入新结点，都能已知起点到各结点的最短路径。图解如下：

![dij01.png](/images/dij01.png "图解Dij算法"){: .align-center}

### 代码实现

核心算法包括1）选取下一个访问节点，2）加入新节点后路线距离的变化，代码如下：

{% highlight js %}
// ----- 选择下一个访问节点 -----
public int updateArr(){
        int minLen = 65535, index = 0;
        for (int i = 0;i<already_arr.length;i++){
            if (already_arr[i] == 0 && dis[i] < minLen){
                // 找到所有没访问过的节点，并找dis里的最小
                minLen = dis[i];
                index = i;
            }
        }
        already_arr[index] = 1;// 代码中唯一更新already的地方
        return index;
    }

// ----- 访问新节点后路径的变化 -----
private void update(int index){
        int len;
        for (int j = 0;j<matrix.length;j++){
            // vv.getDis(j) 是【起点到j的距离】
            // len = vv.dis[index] + matrix[j][index]是新路线，即【起点先到index，再到j的距离】
            // 如果新路线更短，就更新两个数组，否则不用管；
            len = vv.dis[index] + matrix[j][index];

            if(!vv.in(j) && len < vv.getDis(j)){
                vv.updateDis(j,len); // 定下来了，从初始点到j的最短路就是len
                vv.updatePre(j,index);// 定下来了，index就是j的前驱
            }
        }
    }

{% endhighlight %}

### 流程图

最后，迪杰斯特拉算法的流程图：

![flowChart07.png](/images/flowChart07.png "Dij算法-flowChart"){: .align-center}

- 现在再看 dis[] 数组，它表示引入当前这些结点（already表示）的情况下，起点到所有结点的最优路线。比如对上面的图而言，最初只有起点时， dis 是起点到所有点的最短距离，可以看出C和D点是不可达的，因为现在只访问了 G ，并没有通路。当加入 A 后，G 到 C 的最短距离变成了 G-A-C，即 9 ，现在 C 的前驱是 A 。又加入 E 后，到 C 的路线又多了一条 G - E - C 。然而距离更长，因此 dis[2] 没有更新，仍然是先前的 9 。

- 注意，如果新节点的引入使【起点到某个结点的路线】变短，那么更新这个距离以及，新节点作为前驱（最后展示路线）。如果新节点带来的新路线并不是最短，那除了已访问以外，其他无需更新，上一种情况（没new）时的最优路线现在仍然最优。

- 找新的访问结点时有两个条件：1）没访问过，2）当前的最短。那么，1）这个条件是否会使一些最优路线被忽略了？其实是没有的，理论上来说图中所有边都会被考虑一遍。

## 九、弗洛伊德 (Floyd) 算法 - 全部顶点间最短路径

和 Dijkstra 算法一样，弗洛伊德算法也是用于寻找给定的加权图中顶点间最短路径的算法。比较巧妙，实现也容易，但**时间复杂度较高**。和 Dijkstra 不同， Floyd 算法计算的是图中**各顶点之间的最短路径**，而 **Dijkstra 计算的是单某一个顶点到其他顶点**的最短路径。如图， Dijkstra 计算的是事先选出的起点 G 到其他顶点的最短路径，而 Floyd 中每个顶点都作为起点，最后不仅得到 G 的，还有 A 的， B 的 ... 所有的最短路径。

假设某时：

- 顶点 vi 到顶点 vk 的最短路径已知为 Lik。并不一定是直连线，更有可能是折线段，即此时已知vi 到 vk的最优路径；

- 顶点 vk 到 vj 的最短路径已知为 Lkj，同样不一定是一步走到的，更可能是折线，只是当前已知最优最短的路径；

- 顶点 vi 到 vj 的路径为 Lij；

![floyd01.png](/images/floyd01.png "简单考虑三个顶点"){: .align-center}

则： vi 到 vj 的最短路径为：<mark>min( (Lik + Lkj)，Lij )</mark>，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径。注意只是当前最优路径，实际并不一定直接获得，而是通过循环和迭代获得。

上面是思想，更具体一步到实现的数据结构上， Floyd 算法核心是维护两张表，即两个二维数组：**顶点之间距离表【初始就是临接表】** 和 **初始顶点前驱表**。把每个节点都分别作为出发，中转，终点：整体思想是：对这三个数组遍历，首先出发顶点取 A ，中间顶点取 A ，终点是 A ，即。出发顶点取 A ，中间顶点取 A ，终点是 B , C, D, E ......，然后出发顶点A，中间节点 B ，终点A, B, C,... ，每遍历一次（做一步）把最短距离都更新到距离矩阵中。这两张表最终会变成**某顶点到其他顶点的最短距离** 和 ***最短路线**。

- 出发顶点：[A, B, C, D, E, F, G]

- 中间顶点：[A, B, C, D, E, F, G]

- 终点顶点：[A, B, C, D, E, F, G]

具体如下图：二维数组表示起点和终点，每次更新表表示每个节点都当一次中转节点。比如，在第一次更新表时，考虑的是 A 作为中间节点，第一个表的[0,0]表示 A 出发，A 中转，A 终点这个路线的距离；[1,2]表示C出发，A中转，B终点，恰好此路线长12小于更新前的N，于是取代N（红色字体），以此类推。

![floyd02.png](/images/floyd02.png "更新表"){: .align-center}

可能你会问，就三层 for ，每次考虑的不就只是 1-2-3 这种三顶点的简单路径了吗？——无需担心，这样遍历虽然看起来每次都只是 1-2-3 三个节点的简单路径，但每次遍历记录的是 1到2 的**当前最优路径**。在遍历伊始，最优路径很可能是 A - B 这种直连简单路径，但深入遍历后如果 A - G - B 更短，它会代替 A-B ，成为此时的最短路径并分别存入【距离表和路径表】，此后如果遍历到路线 A - B - X ，里面的 A-B 取的都是 A - G - B，脱离了简单路径，同时 B-X 也不是一步走到的，也有可能是复杂路径。**即随着遍历深入，路径存在积累，可能会越来越复杂，越来越贴近实际的最短路线。**表面上每次考虑的只是 A-B ，实际则是 A -i-j-k-...- B 。这样全部遍历下来，所有路径都被考虑到了。然而，显然为了考虑到全部情况，采用的三层 for 循环时间复杂度较高，为O(n^3)。   

### 代码难点

{% highlight js %}
public void floydAlgo(){
        int len = 0;
        // 1.中转
        for (int k = 0;k< vertex.length;k++){
            // 2. 起点
            for (int i = 0;i< vertex.length;i++){
                // 3.终点
                for (int j = 0;j< vertex.length;j++){
                    // 两条路：i-j 和 i-k-j
                    len = dis[i][k] + dis[k][j];
                    if (len < dis[i][j]){
                        dis[i][j] = len;
                        preOrder[i][j] = preOrder[k][j];
                        // 不是 preOrder[i][j] = k！
                    }
                }
            }
        }
    }
{% endhighlight %}

代码唯一难点是**前驱节点如何赋值**。为什么 [i, j] 的前驱节点是 preOrder[k][j] 而不是 k ？看下图：

![floyd03.png](/images/floyd03.png "前驱节点"){: .align-center}

前驱节点表作用是遍历 i-j 的路线，那么为了完整的找到这条路线，我们在赋值前驱节点时，肯定希望在[i,j]位置上反映k1或者k2（无向）的信息，而不是k的信息，才是正确路线。那么什么时候把k的信息更新上呢？回答是在路线 i-k1 或 j-k2 时。说白了，前驱表反映的是 i-j 线路上离 i或j 最近的那个点 k1或k2 ，这样才能：
1. 输入 i,j ，得到k1，
2. 再输入i，k1，得到k，
3. 再输入i，k，得到k2，
4. 再输入i，k2，得到i，
5. 最后的路线就是 j-k1-k-k2-i

在构造器中，我们初始化 preOrder 数组为 preOrder[i][j] = i ，即每次都选择离终点最近的节点为 [i, j] 路线的前驱节点（如图1）。然后，对于 i，j 中间有一个直达 k 的情况（图2），显然我们应该返回的是离 j 最近的 k ，即 preOrder[i][j] 应该 = k ，而黄色框内的两节点恰好又构成了图1情况，因此有 preOrder[k][j] = k， 所以对于图2有：pre[ i ][ j ] = k = pre[ k ][ j ] 。最后看图3：k 节点作为中间节点，由图2已知 pre[ i ][ j ] =  pre[ k ][ j ]，红色框内恰好又构成图2情况，因此有 pre[ k ][ j ] = pre[ k1 ][ j ] = k1 。综上，每次选离**终点**最近的节点为 [i, j] 路线的前驱节点的公式为：pre[ i ][ j ] =  pre[ k ][ j ] 。相应的，每次选离**起点**最近的节点应该是 pre[ i ][ j ] =  pre[ i ][ k ] ，对应的初始化要改一下。但是肯定不能写preOrder[i][j] = k。最后，**打印路径的步骤**也很简单，设起点 i ，终点 j ，首先找到 [i,j] 的前驱为 z，[i,z] 的前驱为 y，[i,y] 的前驱 x ... ，直到某个 [i,x] 的前驱为 i 为止，路线用数组存起来反向打印，呼之欲出，就是 j-z-y-x-i 。如图，我们验证一下 C 到 D 的最短路径（红色）：pre[C, D] = 5(即F)，pre[C, F] = 4(即E)，pre[C, E] = 2(即C)，结束，路径为 【D - F - E - C】，没有问题。

再回头看看 Floyd 算法中存放距离的二维数组，这种每次加入一个节点的思想，有没有想到 Dij 算法？事实上，最后得到的二维数组的行/列，恰好就是 Dij 算法的**dis**数组。不过思想上有差别：Dij算法是每次加入当前最短节点，Floyd是随意加哪个都行。意义都是每次加入一个节点，不断更新当前最优的【出发结点到其他结点的最短距离】和【各结点的前驱结点】，Dij 多了一个已访问节点，是针对单一顶点的最短路径，Floyd 则是所有节点的最短路径都算出来，因此考虑情况更多，遍历的条件更松弛。

### 流程图

最后， Floyd 算法的流程图如下：

![flowChart08.png](/images/flowChart08.png "flowChart-Floyd"){: .align-center}

### 贯穿始终的 DP 思想

可以看到，以上四个算法都符合动态规划 DP 的思想：用表、数组保存当前最优解，并逐步更新状态（加入新节点），求新的最优并更新。和经典 DP 的区别在于： DP 的状态转移方程非常明确（如01背包），另一个的状态转移并不明确，要针对新情况自己设计，并手动求解（因为谁也不知道新加入的节点和哪个节点连着，以及连接的距离有多长）。我认为后者更普适，即状态转移的规律更不明显时，要写函数来计算状态。

## 十、骑士周游问题 / 马踏棋盘算法

马踏棋盘算法也被称为骑士周游问题。将马随机放在国际象棋的 8×8 棋盘Board [0～7][0～7] 的某个方格中，马按走棋规则(**马走日字**)进行移动。要求每个方格只进入一次，走遍棋盘上全部 64 个方格。

![horse01.png](/images/horse01.png "马踏棋盘"){: .align-center}

如图所示，暗色的123456表示马已经走过的方格，不能再进入，白色的马轮廓表示这些是本次马可以
走到的方格，如此循环直到走遍棋盘上全部方格。

马踏棋盘问题(骑士周游问题)实际上是图的**深度优先DFS**的应用。如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：假如走到了第 53 个，坐标 （1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，因此会在棋盘上不停的回溯。类似**八皇后问题和迷宫问题**，直到不能走通的地方回退，然后再进。

思路如下：

1. 创建棋盘 chessBoard （二维数组存放）；
2. 马走日，每次最多走8个点，为了判断哪个不能走，每走一步，都要：1）将当前位置设置为已访问，并根据当前位置计算马儿可以走哪些位置，放入可走的集合。2）还要记录这是走的第几步 （step++）。
3. 遍历可走集合中的所有位置，看哪个可以走通，能走通则回到第2步，不能走就回溯。
4. 判断马儿是否完成任务？全走一遍算结束，所以比较 step 和棋盘大小，如果这次不能完成任务，【就当马儿没来过】：将当前位置设置为未访问（虽然这条路线不通，但其他路线终究还是要走到这的），并将整个棋盘置0（为了找路线）。

### 流程图

最后，程序的流程图如下：

![flowChart09.png](/images/flowChart09.png "flowChart-HorseChessBoard"){: .align-center}

借助流程图，再说一下回溯：

![flowChart10.png](/images/flowChart10.png "flowChart-HorseChessBoard-enhanced"){: .align-center}

如图，【蓝，黄，红】分别对应【左，中，右】三个棋盘。蓝色框中的节点 A 从可走集合中取出一个 B 点，判断可走后，对 B 点同样执行方法（黄色是 B 的方法体）。 B 点执行方法，从 B 的可走中取出一个 C ， C 执行方法（红色）。假设 C 的可走点集合为空了（C走到死胡同了），那么有两种情况：

- （1）棋盘已经全走过一遍；**程序结束**，在二维数组里给出路线。

- （2）**棋盘还没有全走过一遍：将放弃这条路线**：首先 C 变成未访问，红色框结束，然后回到黄色框中的红色，B 会在它的可走点集中 继续挑一个可用节点，继续执行方法。倘若此时 B 的可走点集合也空了，那么先清空 B ，回到蓝色框继续执行 A 的方法。如此递归（找下一个），回溯（放弃路线，清空并回上一个），直到找到路线为止（当然了，一定得有解，不然停不下来）。

很明显这种“不撞南墙不回头，撞了再回上一个岔路”的思想是 **DFS** 。回溯是一定的，但我们确实可以适当减少回溯的可能性，提升代码性能。看图：

![horse02.png](/images/horse02.png "如何回溯"){: .align-center}

两种选路方式，第一种尽量贴边，让可走集合尽量小一点，如果用树结构存储可能的路线，【注意】这只是前三步，后面还有好多好多步。第一种的路线是这样的：

![horse03.png](/images/horse03.png "回溯，还好"){: .align-center}

路线不多，回溯起来压力不大。但是第二种每次都往中间走，这样每次的集合都很大，可能的路线是这样的：

![horse04.png](/images/horse04.png "这也太多了"){: .align-center}

显然第二种路线回溯时长一定比第一种慢很多。在代码里，我们是指定每次先走左上角，左上角不行走右上角...这样的，也就是没有对可走点集合的大小作出约束，出现高时长也是不可避免的。那么对集合加以约束，就能优化算法了。这里我们选择此前用到的贪心算法，即每次都选择当前看起来最好的解，虽然不是最优，但是一定贴近最优。

### 优化——贪心算法

依然以上面三步来看，走到 A 的时候我们得到了 A 的集可走点集合，【B, C, D, E, F】。而下一步的点【 B, C, D, E, F 】也有它们继续可走的集合。那么，对 B, C, D, E, F 以其各自【可走集合大小】进行排序，得到 【D, C, B, F, E】，其中 D 的可走集合最小，就从 A 先走到 D 。如图，马儿有两个可走： 1 和 2 ，其中 1 的可走只有 1 个，即紫色，但 2 的可走有 5 个，那么就让马儿走到 1 ，如果 1 路线不行，再回溯到 2 ，以此类推。同样按照树结构来理解，这样做是把：孩子多的节点放下面，孩子少的节点放上面。

![horse05.png](/images/horse05.png "贪心的马儿"){: .align-center}

优化前后的时间对比也是很明显的：

![horse06.png](/images/horse06.png "应用贪心算法的效果"){: .align-center}