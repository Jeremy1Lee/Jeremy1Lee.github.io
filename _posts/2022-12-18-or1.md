---
layout: post
title: "列生成算法"
author: LJC
tags:
- OR & Algorithm
date: 2022-12-18 10:20 +0800
toc: true
---

决策变量很多，但约束条件不多的线性规划问题
{: .message }

## 应用场景

列生成算法Column generation：大规模混合整数规划问题中，**决策变量非常多**。如果同时又是整数规划，甚至松弛解都不好求，模型的线性松弛很差。

问题在于：变量多，导致单纯形法 系数矩阵列太多，需要的内存或时长大。列生成算法的思想是：只考虑必要的列，实际属于单纯形法的改进，常用于机组人员调度问题、下料问题。

**思想**仍然是将原来的MIP分解成为一个主问题（Master Problem）和若干个子问题（Subproblem），然后迭代求解。其**缺点**是精确式算法，同时只能用于求解线性规划问题；

## 举例：下料问题

如图所示，有一堆固定长度为17m的原料。不同客户需要的原料长度不同，有3m、5m、7m三种。如何裁剪原料满足客户需求，并使浪费最少？

![cg-1.png](/images/or/cg-1.png)

首先对问题建模：以下图的裁剪方式为例：

![cg-2.png](/images/or/cg-2.png)

明确决策变量后，原问题 Master Problem 可以表示如下：

![cg-3.png](/images/or/cg-3.png)

其中，n 是各方案的总数，我们并不需要确切的知道这个值是多少，只需要知道它很大。

## 举例：车辆路径问题

假设有3个客户,其位置和需求量如下:
- 客户1: (1,2) 需求量:3
- 客户2: (4,5) 需求量:6
- 客户3: (8,1) 需求量:4
- 车辆容量为10

目标是最小化车辆行驶总距离。初始解只考虑客户1和客户2，路过一次1一次2，形成初始路线 {(0,0)→(1,2)→(4,5)→(0,0)}。

构建子问题，考虑连接客户3的新路径的成本减少量，向主问题添加新列，通过迭代地添加列，直到无法添加。s

## 列生成算法

以下料问题为例，开始列生成算法：
- 首先，需要一个初始解（可以通过启发式算法），例如下图：
    - ![cg-4.png](/images/or/cg-4.png)

- 那么，现在的 restricted master problem , RMP 为：
    - ![cg-5.png](/images/or/cg-5.png)
    - 这三个变量为基变量，显然 RMP 的解不是最优解，甚至离最优解还很远

- 还有一点需要注意：对于每一列，都需要满足：
    - ![cg-6.png](/images/or/cg-6.png)
    - 即列生成规则，也就是每一个原料为16m，怎么切都不能超出这个长度。在寻找某些列或者生成某些列时，就是受到列生成规则的约束的。

- 生成列（方案4，包括系数）：设置子问题：
    - ![cg6-1.png](/images/or/cg6-1.png)
    - 子问题的目标函数是：计算**非基变量的**检验数，如果非负，寻找最小的非基变量入基
    - ![cg-7.png](/images/or/cg-7.png)

- 求解子问题结果得 [1,2,0]，这就是方案4了，即 1*3m，2*5m

- 回到第二步，现在的 RMP 有四个基变量：
    - ![cg-8.png](/images/or/cg-8.png)  
    - 相应的模型为：
    - ![cg-9.png](/images/or/cg-9.png)  

- 重新计算 非基变量检验数 ，现在的子问题如下，求解子问题可以得到方案5（的系数）：
    - ![cg-10.png](/images/or/cg-10.png)  

- 继续迭代，直到所有非基变量的检验数都是正数（正数 对应本例的min），停止迭代

注意，在列生成时（子问题时）我们把模型松弛为线性模型，因为列生成是用于求解LP的。如果子问题最优解不是整数，还要在列生成中结合分支定界、分支定价等方法。

## 总结

列生成算法其实是单纯形法的改进，适用于变量很多的大规模问题，但与单纯形法类似，它只能解决线性规划问题。与单纯形法不同的是，单纯形法计算所有的基变量，并通过检验数计算入基出基，而列生成在初始解的基础上通过一个子问题（仍然是检验数），决定入基变量。步骤如下：
1. 不明确全部的变量,仅考虑一个变量子集,得到一个主问题。
2. 求解主问题,得到一组对偶变量值。
3. 根据对偶变量值,构建一个规划子问题,寻找能改善主问题目标函数的新变量。
4. 如果找到新的变量,加入主问题,重新求解主问题。否则问题求解结束。
