<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>生命不止，折腾不息</title>
    <description>生命不止，折腾不息</description>
    <link>https://dongyadoit.com/</link>
    <atom:link href="https://dongyadoit.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 19 Dec 2021 22:30:39 +0800</pubDate>
    <lastBuildDate>Sun, 19 Dec 2021 22:30:39 +0800</lastBuildDate>
    <generator>Jekyll v4.2.1</generator>
    
      <item>
        <title>在 Electron 中使用 WebAssembly</title>
        <description>&lt;p&gt;Wasm 在浏览器的使用日趋常见，被经常用来做一些图像，音频，绘图，性能相关的处理。而 electron 本身就是使用 Chromium 内核的桌面应用 app 开发框架，自然也可以使用 wasm。&lt;/p&gt;

&lt;h3 id=&quot;引入-wasm&quot;&gt;引入 wasm&lt;/h3&gt;
&lt;p&gt;Electron 打包之后访问的是本地 html 文件，一般编译完成后引入在 html 里面直接引入:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;/path/to/wasmlib.js&quot; &amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;wasmlib.js 会自动加载 wasmlib.wasm 文件并初始化，通过 Module 提供的回调函数获取初始化结果的通知&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Module.onRuntimeInitialized = async _ =&amp;gt; {
    // wasm lib initialized 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sharedarraybuffer-报错&quot;&gt;SharedArrayBuffer 报错&lt;/h3&gt;
&lt;p&gt;SharedArrayBuffer被经常用于 worker 中的数据共享，如果 wasm 中有使用 ，在高版本浏览器（chrome 92 开始)上不能使用，会直接提示并报错:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[Deprecation] SharedArrayBuffer will require cross-origin isolation as of M92, around July 2021. See https://developer.chrome.com/blog/enabling-shared-array-buffer/ for more details.
Uncaught ReferenceError: SharedArrayBuffer is not defined
    at wasmlib.js:1074
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是因为在高版本上，chrome 对 SharedArrayBuffer 使用启用了更严格的安全限制，必须在服务器上配置了以下选项才能被使用：&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# COEP 跨域嵌入策略，会阻止页面加载任何未明确授予文档许可权的跨域资源（使用CORP或CORS）。
Cross-Origin-Embedder-Policy: require-corp
# COOP 
Cross-Origin-Opener-Policy: same-origin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上配置一般只能在 web 服务器配置，所以最初的方案是在 electron 内部启用个 web 服务器增加以上的头信息，然后通过 http 协议加载应用文件（相当于打开个在线网站），但是会带来很明显的性能问题，首页打开会非常慢。&lt;/p&gt;

&lt;h3 id=&quot;最终解决方案&quot;&gt;最终解决方案&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;使用 electron 提供的 session 设置增加返回头信息:
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; session.defaultSession.webRequest.onHeadersReceived((details, callback) =&amp;gt; {
     callback({
         responseHeaders: {
             ...details.responseHeaders,
             'Cross-Origin-Opener-Policy': 'same-origin',
             'Cross-Origin-Embedder-Policy': 'require-corp',
         },
     });
 });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;通过 BrowserWindow.LoadFile(“/path/to/app.html”) 加载本地 html 文件。&lt;br /&gt;
基于此，app 不需要内嵌一个 web 服务器，本地文件也可以使用SharedArrayBuffer 的功能，速度也得到很大的提升。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 12 Dec 2021 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/webassembly/2021/12/12/use-webassembly-in-electron/</link>
        <guid isPermaLink="true">https://dongyadoit.com/webassembly/2021/12/12/use-webassembly-in-electron/</guid>
        
        <category>webassembly</category>
        
        
        <category>webassembly</category>
        
      </item>
    
      <item>
        <title>SharedArrayBuffer 以及在跨域中的使用</title>
        <description>&lt;h3 id=&quot;什么是跨域&quot;&gt;什么是跨域&lt;/h3&gt;
&lt;p&gt;跨域问题是前端开发人员面前绕不过去的问题。&lt;br /&gt;
所谓跨域，通俗点表达，就是当前站点，请求或加载了其他域名的资源。
比如当前 app.a.com 请求了  file.b.com 的资源，就产生了跨域资源的加载。&lt;/p&gt;

&lt;p&gt;浏览器在渲染当前页面时，校验网页请求的资源是否可以安全的在当前页面使用。
比如：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;是同站点下的资源，比如 app.a.com/logo.png，可以直接使用&lt;/li&gt;
  &lt;li&gt;如果是同域名下的资源，比如 file.a.com/logo.png, 这时会校验文件的响应头，看有没有配置 Access-Control-Allow-* 相关的访问控制参数&lt;/li&gt;
  &lt;li&gt;如果是 file.b.com/logo.png 同样也会去校验访问控制信息信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果资源的访问控制信息不能表面资源可以在当前站点使用，就会产生跨域的问题，浏览器会禁止资源的加载和展示。
也就是说跨域问题其实是浏览器对资源使用安全策略产生的，浏览器要保证站点访问资源是安全，合法访问的。&lt;/p&gt;

&lt;p&gt;浏览器是否可以使用某个资源有两个限制：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;当前站点是否允许使用其他站点，域名的资源
站点可以配置是否允许访问其他域名的资源，比如在站点配置一些安全策略&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# COEP 跨域嵌入策略，会阻止页面加载任何未明确授予文档许可权的跨域资源（使用CORP或CORS）。
Cross-Origin-Embedder-Policy: require-corp
# COOP 
Cross-Origin-Opener-Policy: same-origin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;请求的资源是否可以在当前站点使用
资源是否开启了跨域资源共享策略，决定资源在哪些站点可以被使用，一般解决跨域的时候，需要在资源的响应头中配置以下选项&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 跨域资源策略
Cross-Origin-Resource-Policy: same-site | same-origin | cross-origin
# cross-origin 表示该资源被任何站点使用

# 允许通过哪些方法访问
Access-Control-Allow-Methods: GET | POST | PUT | OPTIONS | HEAD

# 允许哪些域名访问， * 代表所有，一般来说不安全
Access-Control-Allow-Origin: *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;什么是-sharedarraybuffer&quot;&gt;什么是 SharedArrayBuffer&lt;/h3&gt;
&lt;p&gt;SharedArrayBuffer(以下简称 SAB) 是一个 javascript 对象，用于网站线程之间的内存数据共享，比如 worker。同样由于 WebAssembly 使用 worker 模拟了多线程，所以在这种情况下同样会使用到 SAB 做数据共享访问。&lt;/p&gt;

&lt;h3 id=&quot;为什么使用-sab-会遇到跨域问题&quot;&gt;为什么使用 SAB 会遇到跨域问题&lt;/h3&gt;
&lt;p&gt;18年 spectre 曝光之前，已经有不少网站使用了 SAB。由于 spectre 是 cpu 层面的漏洞，不太可能通过cpu 升级去解决，因此当时所有浏览器直接禁用了 SAB，来防止 spectre 的旁路攻击。&lt;/p&gt;

&lt;p&gt;那么什么是 spectre 攻击，用通俗一点的话来说，就是 cpu 有一个机制，叫做预测机制，假如有一个恶意程序去查询一个没有权限的信息，操作系统会返回禁止的信息，本身来说这个逻辑当然没有问题。但是当恶意程序询问时，其实操作系统即使返回了禁止的信息，但是还是会因为预测机制会去执行正确答案的逻辑，会导致慢了一小段时间，比如几微秒，几毫米，这就被恶意程序注意到了，通过每隔一段时间不断去尝试询问，达到获取正确答案的效果。&lt;/p&gt;

&lt;p&gt;恶意程序可以通过  SAB 获取到其他页面的敏感信息。我们都知道 worker 在浏览器中有很大的限制，比如不能访问 window, document 对象， SAB 是用来和主线程进行数据交换访问的高效方法，也被大量应用，这就会导致 worker 是有办法通过 SAB 攻击获取到主线程的敏感信息。&lt;/p&gt;

&lt;p&gt;所以在 spectre 漏洞曝出时，几乎所有主流浏览器都默认关闭了 SAB 以应对这个漏洞的攻击。&lt;/p&gt;

&lt;h3 id=&quot;如何解决&quot;&gt;如何解决&lt;/h3&gt;
&lt;p&gt;SAB 作为 WebAssembly(wasm) 模拟多线程的基础组件，如果不能使用，将会对 wasm 在某些应用场景的性能大幅下降。重新启用是势在必行。&lt;br /&gt;
在 chrome 92 之前， chrome 是默认开启 SAB 的，但是已经弹出警告信息提示 SAB 将会在 92 版本必须启用以下选项：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# COEP 跨域嵌入策略，会阻止页面加载任何未明确授予文档许可权的跨域资源（使用CORP或CORS）。
Cross-Origin-Embedder-Policy: require-corp
# COOP 
Cross-Origin-Opener-Policy: same-origin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也就是说加载的资源必须有 corp 策略的头信息， 跨域打开者也是同域名&lt;/p&gt;

&lt;h3 id=&quot;相关资料&quot;&gt;相关资料&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;关于 SharedArrayBuffer spectre 攻击的讨论
https://github.com/tc39/security/issues/3&lt;/li&gt;
  &lt;li&gt;使用 SharedArrayBuffer 进行 Spectre 攻击的原理
https://www.giantbranch.cn/2018/01/09/%E8%85%BE%E8%AE%AF%E7%8E%84%E6%AD%A6%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8spectre%E7%9A%84%E5%8E%9F%E7%90%86/&lt;/li&gt;
  &lt;li&gt;为什么需要“跨域隔离”才能获得强大的功能&lt;/li&gt;
  &lt;li&gt;Same origin : https://web.dev/same-origin-policy/&lt;/li&gt;
  &lt;li&gt;跨域隔离启用指南： https://web.dev/cross-origin-isolation-guide/&lt;/li&gt;
  &lt;li&gt;https://v8.dev/blog/spectre&lt;/li&gt;
  &lt;li&gt;https://web.dev/coop-coep/&lt;/li&gt;
  &lt;li&gt;https://www.cnblogs.com/Shepherdzhao/p/8253421.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 19 Sep 2021 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/webassembly/2021/09/19/use-shared-array-buffer-and-used-in-cors-copy/</link>
        <guid isPermaLink="true">https://dongyadoit.com/webassembly/2021/09/19/use-shared-array-buffer-and-used-in-cors-copy/</guid>
        
        <category>webassembly</category>
        
        
        <category>webassembly</category>
        
      </item>
    
      <item>
        <title>在 WebAssembly 中实现回调的方式</title>
        <description>&lt;p&gt;本文将介绍在 C++ 中实现 js 回调的几种方式. 在使用 wasm 的过程中, 避免不了要从 C++ 回调 js 的函数来实现异步交互.&lt;/p&gt;

&lt;p&gt;官网文档 https://emscripten.org/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#&lt;/p&gt;

&lt;p&gt;中已经介绍了6种实现回调的方式, 这里介绍几种能解决实际问题的方式&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;em_asm-相关参数介绍&quot;&gt;EM_ASM 相关参数介绍&lt;/h3&gt;

&lt;p&gt;EM_ASM 函数簇包含&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EM_ASM
EM_ASM_INT
EM_ASM_DOUBLE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类似的使用方式 :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EM_ASM_({
            postMessage({cmd: 'callback', text: &quot;callback&quot;, threadId: $2, callId : $0, code : $1})
        }, callback, code, tid);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 $0, $1, $2 分别代表 callback, code, tid 的值.&lt;/p&gt;

&lt;p&gt;后面两个函数还可以获取到 js 返回的 int/ double 值. 一般能满足简单的使用.&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;如何在-worker-中实现回调&quot;&gt;如何在 worker 中实现回调&lt;/h3&gt;

&lt;p&gt;使用 wasm 的时候, 某些任务会被放到 worker 中执行, 执行完成后回调通知结果.&lt;/p&gt;

&lt;p&gt;这个时候要特别注意: worker 和主线程是相互独立的, 并不能像普通的多线程可以共享进程内的数据. 在 worker 中调用 js 回调时, 第一个面临的限制就是 web worker 的限制:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不能访问 window, document 对象&lt;/li&gt;
  &lt;li&gt;与主线程通信需要通过 post message 方式&lt;/li&gt;
  &lt;li&gt;不能访问主进程中的全局变量会对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果直接在 worker 中直接调用回调, 就只能做一些简单的事情. 为此 emscripten 提供了以下函数:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MAIN_THREAD_EM_ASM
MAIN_THREAD_EM_ASM_INT
MAIN_THREAD_EM_ASM_DOUBLE
MAIN_THREAD_ASYNC_EM_ASM
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;顾名思义就是在主线程中执行函数. 但是前面 3 个函数不管在哪个线程调用都会会阻塞主线程.&lt;/p&gt;

&lt;p&gt;推荐使用最后一个 MAIN_THREAD_ASYNC_EM_ASM, 区别就是在如果是主线程调用该函数,会被理解执行,如果是在其他线程调用,则会被追加到主线程的任务队列再被执行.&lt;/p&gt;

&lt;p&gt;至于如何实现这个功能了, emscripten 也突破不了这个限制, 也是通过 postMessage 的通信机制实现的.&lt;/p&gt;

&lt;p&gt;在不熟悉 emscripten 的时候我自己模拟了这个过程:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在主线程注册函数, 保存在一个特定的对象中, 并产生一个 callid&lt;/li&gt;
  &lt;li&gt;把callid 传到 worker 中,使用上述的 EM_ASM 回调&lt;/li&gt;
  &lt;li&gt;子线程会把信息 post 到主线程&lt;/li&gt;
  &lt;li&gt;主线程收到 message 和 callid, 去特定的对象查找到已经注册的回调函数, 执行函数,完成回调&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;如何在回调中传递字符串&quot;&gt;如何在回调中传递字符串&lt;/h3&gt;
&lt;p&gt;在 emscripten 值的传递, 除了基本类型是通过拷贝的, 字符串和数组,内存都是通过指针地址去传递.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    std::string data = &quot;{\&quot;code\&quot; : 0, \&quot;msg\&quot; : \&quot;/input.mp4\&quot;}&quot;
    MAIN_THREAD_ASYNC_EM_ASM({
         var dataStr = UTF8ToString($0);
         console.log(dataStr)
    }, data.c_str());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在回调函数中,通过 UTF8ToString 函数把传递过去的指针转成 js 的字符串, 这样来达到传递字符串的目的.&lt;/p&gt;
</description>
        <pubDate>Sun, 31 Jan 2021 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/webassembly/2021/01/31/implement-callback-in-webassembly/</link>
        <guid isPermaLink="true">https://dongyadoit.com/webassembly/2021/01/31/implement-callback-in-webassembly/</guid>
        
        <category>webassembly</category>
        
        
        <category>webassembly</category>
        
      </item>
    
      <item>
        <title>WebAssembly 在 Web 端视频的应用</title>
        <description>&lt;p&gt;WebAssembly 从诞生起，赋予了前端更宽阔的应用想象。绘图视频渲染，剪辑，编解码，游戏都有可能基于 WebAssembly 在浏览器端推出相关的产品。&lt;/p&gt;

&lt;h3 id=&quot;什么是-webassembly&quot;&gt;什么是 WebAssembly&lt;/h3&gt;

&lt;p&gt;WebAssembly（wasm） 是一种二进制代码格式, 具有高效，跨平台性，包含这种格式的二进制文件，可以被各个平台的浏览器高效的加载，解析执行。&lt;/p&gt;

&lt;p&gt;只要浏览器支持 wasm， 用户便可以使用 wasm 所提供的功能，也就是说 wasm 的跨平台性其实是基于浏览器的跨平台性。上层用户编译 wasm 时，&lt;br /&gt;
不需要关注底层架构是什么，只要编译出来正确的二进制文件，就可以在各个支持的浏览器运行。&lt;/p&gt;

&lt;p&gt;wasm 增强了 js 的能力，js 不擅长做的事情，比如绘图，编码，解码，数学计算等，都可以在 wasm 中实现，然后 js 就可以使用wasm所提供的能力。&lt;/p&gt;

&lt;p&gt;现阶段已经有很多 WebAssembly 的应用，比如 ffmpeg 的编解码应用， unity 3d, unreal engine， google earth等都相继支持了 wasm。&lt;/p&gt;

&lt;h3 id=&quot;如何使用&quot;&gt;如何使用&lt;/h3&gt;

&lt;p&gt;WebAssembly 现在支持从 C/C++, go, rust 编译成 wasm 模块。使用 emscripten sdk, 可以从 C/C++ 源码直接编译成 wasm 文件，然后在网页中
直接加载使用。&lt;/p&gt;

&lt;p&gt;参考 https://emscripten.org/docs/getting_started/Tutorial.html 入门。&lt;br /&gt;
参考 https://emscripten.org/docs/compiling/Building-Projects.html 编译项目。&lt;/p&gt;

&lt;p&gt;但是如何从网页调用 wasm 的方法。两种方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直接使用 emscripten 提供的底层函数，把wasm 的方法导出到 js 运行环境中。&lt;/li&gt;
  &lt;li&gt;在底层使用 embinding 直接导出 c/c++ 的函数和类，然后在 js 中调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;如果应用在视频剪辑中&quot;&gt;如果应用在视频剪辑中&lt;/h3&gt;
&lt;p&gt;基于 wasm 提供的能力，ffmpeg 解码， 图片解码， OpenGL, 多线程，视频剪辑应用的结构图如下， 该系列文章，会不定期更新，介绍基于此图的架构和技术原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/wasm.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考在线演示 demo: http://cloudedit.atvideo.cc&lt;/p&gt;

&lt;h3 id=&quot;wasm-的限制和风险&quot;&gt;wasm 的限制和风险&lt;/h3&gt;
&lt;p&gt;wasm 的限制与不便&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;运行在一个沙盒中，网页和 js 的限制， wasm 同样会有，比如跨域&lt;/li&gt;
  &lt;li&gt;不能直接读取用户计算机磁盘上的文件&lt;/li&gt;
  &lt;li&gt;能使用的最大内存有限制，各个浏览器的限制都不同，一般为 2G&lt;/li&gt;
  &lt;li&gt;现阶段已经支持了多线程（基于 worker 和 SharedArrayBuffer), 其中 SharedArrayBuffer 在有些浏览器不会默认开启&lt;/li&gt;
  &lt;li&gt;wasm 中申请的内存也需要手动释放&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;技术本身不会有太多的风险，在于如何去使用。已经出现过基于 wasm 技术开发的挖矿程序，病毒等。&lt;br /&gt;
由于 wasm 是更低级的二进制格式，网页端在这方面的安全检查和拦截还不成熟。现阶段使用了 wasm 技术的网站可能会有更大的安全风险。&lt;/p&gt;

&lt;p&gt;随着各大浏览器对 wasm 的完善， wasm 能支持的功能会更多。比如 gc, 更好的异常处理,届时能实现更高效和全面的功能。&lt;/p&gt;
</description>
        <pubDate>Sun, 29 Nov 2020 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/webassembly/2020/11/29/use-webassembly-render-video/</link>
        <guid isPermaLink="true">https://dongyadoit.com/webassembly/2020/11/29/use-webassembly-render-video/</guid>
        
        <category>webassembly</category>
        
        
        <category>webassembly</category>
        
      </item>
    
      <item>
        <title>Linux 动态库 undefined symbol 原因定位与解决方法</title>
        <description>&lt;p&gt;在使用动态库开发部署时，遇到最多的问题可能就是 undefined symbol 了，导致这个出现这个问题的原因有多种多样，快速找到原因，采用对应的方法解决是本文写作的目的。&lt;/p&gt;

&lt;h3 id=&quot;可能的原因&quot;&gt;可能的原因&lt;/h3&gt;

&lt;h4 id=&quot;1-依赖库未找到&quot;&gt;1. 依赖库未找到&lt;/h4&gt;
&lt;p&gt;这是最常见的原因，一般是没有指定查找目录，或者没有安装到系统查找目录里&lt;/p&gt;

&lt;h4 id=&quot;2-链接的依赖库不一致&quot;&gt;2. 链接的依赖库不一致&lt;/h4&gt;
&lt;p&gt;编译的时候使用了高版本，然后不同机器使用时链接的却是低版本，低版本可能缺失某些 api&lt;/p&gt;

&lt;h4 id=&quot;3-符号被隐藏&quot;&gt;3. 符号被隐藏&lt;/h4&gt;
&lt;p&gt;如果动态库编译时被默认隐藏，外部代码使用了某个被隐藏的符号。&lt;/p&gt;

&lt;h4 id=&quot;4-c-abi-版本不一致&quot;&gt;4. c++ abi 版本不一致&lt;/h4&gt;
&lt;p&gt;最典型的例子就是 gcc 4.x 到 gcc 5.x 版本之间的问题，在  4.x 编辑的动态库，不能在 5.x 中链接使用。&lt;/p&gt;

&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;

&lt;h4 id=&quot;1-依赖库未找到-1&quot;&gt;1. 依赖库未找到&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用 ldd -r &lt;lib-file-name&gt;, 确定系统库中是否存在所依赖的库&lt;/lib-file-name&gt;&lt;/li&gt;
  &lt;li&gt;执行  ldconfig 命令更新 ld 缓存&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;执行 ldconfig -p&lt;/td&gt;
          &lt;td&gt;grep {SO_NAME} 查看是否能找到对应的库&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;检查 LD_LIBRATY_PATH 是否设置了有效的路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-链接的库版本不一致&quot;&gt;2. 链接的库版本不一致&lt;/h4&gt;

&lt;p&gt;如果系统中之前有安装过相同的库，或者存在多个库，就需要确定链接的具体是哪个库&lt;/p&gt;

&lt;p&gt;有一个特殊场景需要注意下，.so 文件中有个默认 rpath 路径，用于搜索被依赖的库，这个路径优先于系统目录和LD_LIBRARY_PATH。假如 rpath 存在相同名字的 .so 文件，会优先加载这个路径的文件。&lt;/p&gt;

&lt;p&gt;在遇到 undefined symbol 问题时，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readelf -d &amp;lt;lib-file&amp;gt; | grep - i rpath&lt;/code&gt; 查看:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ readelf -d libSXVideoEngineJni.so | grep rpath
 0x000000000000000f (RPATH)              Library rpath: [/home/slayer/workspace/SXVideoEngine-Core/Render/cmake-build-debug:/home/slayer/workspace/SXVideoEngine-Core/Render/../../SXVideoEngine-Core-Lib/blend2d/linux/lib]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果存在的路径中有相应的库，可以先重命名文件再测试确认。&lt;/p&gt;

&lt;p&gt;关于连接时的顺序可以查看文档： http://man7.org/linux/man-pages/man8/ld.so.8.html&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   If a shared object dependency does not contain a slash, then it is
   searched for in the following order:

   o  Using the directories specified in the DT_RPATH dynamic section
      attribute of the binary if present and DT_RUNPATH attribute does
      not exist.  Use of DT_RPATH is deprecated.

   o  Using the environment variable LD_LIBRARY_PATH, unless the
      executable is being run in secure-execution mode (see below), in
      which case this variable is ignored.

   o  Using the directories specified in the DT_RUNPATH dynamic section
      attribute of the binary if present.  Such directories are searched
      only to find those objects required by DT_NEEDED (direct
      dependencies) entries and do not apply to those objects' children,
      which must themselves have their own DT_RUNPATH entries.  This is
      unlike DT_RPATH, which is applied to searches for all children in
      the dependency tree.

   o  From the cache file /etc/ld.so.cache, which contains a compiled
      list of candidate shared objects previously found in the augmented
      library path.  If, however, the binary was linked with the -z
      nodeflib linker option, shared objects in the default paths are
      skipped.  Shared objects installed in hardware capability
      directories (see below) are preferred to other shared objects.

   o  In the default path /lib, and then /usr/lib.  (On some 64-bit
      architectures, the default paths for 64-bit shared objects are
      /lib64, and then /usr/lib64.)  If the binary was linked with the
      -z nodeflib linker option, this step is skipped.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-符号被隐藏-1&quot;&gt;3. 符号被隐藏&lt;/h4&gt;

&lt;p&gt;第三方已经编译好的库，在引入了对应的头文件，使用了其中的某个方法，最终链接的时候出现 undefined symbol，这种情况有可能是库的开发者并没有导出这个方法的符号。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 使用 nm 命令查看导出的函数符号， 这里查看 License 相关的函数
$ nm -gDC libSXVideoEngineJni.so | grep -i license
0000000000008110 T __ZN13SXVideoEngine6Public7License10SetLicenseEPKc
0000000000008130 T __ZN13SXVideoEngine6Public7License13LicenseStatusEv
0000000000008190 T __ZN13SXVideoEngine6Public7License19IsVideoCutSupportedEv
0000000000008170 T __ZN13SXVideoEngine6Public7License26IsDynamicTemplateSupportedEv
0000000000008150 T __ZN13SXVideoEngine6Public7License26IsStadardTemplateSupportedEv

# nm 返回的并不是原始函数名，通过 c++filt 获取原始名称
$ c++filt __ZN13SXVideoEngine6Public7License10SetLicenseEPKc
SXVideoEngine::Public::License::SetLicense(char const*)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4-c-abi-版本不一致-1&quot;&gt;4. c++ Abi 版本不一致&lt;/h4&gt;

&lt;p&gt;Gcc 对 c++ 的新特性是一步一步的增加的，如果实现了新的特性，就可能会修改 c++ 的 abi，并且会升级 glibc 的版本。&lt;/p&gt;

&lt;p&gt;Abi 链接最常见的错误是 std::string 和 std::list 的在gcc 4.x 和 gcc 5.x 的不同实现引起的。在gcc 4.x 时，gcc 对标准 string 的实现就放在 std 命名空间下，编译时展开为 std::basic_string 。但是 gcc 5.x 开始，对 string 的实现就放在了 std::__cxx11空间里，编译后展开为 std::__cxx11::basic_string 。这就会导致在 gcc 4.x 编译的动态库，假如有的函数使用了 string 作为参数或者返回值，这时导出的函数参数为 std::basic_string 类型。 无法在 gcc 5.x 下编译连接使用。&lt;br /&gt;
错误类似：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;undefined symbol:  &quot;std::__cxx11 ***&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种情况有一个折中办法就是在gcc 5.x 或以上 编译时，增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-D_GLIBCXX_USE_CXX11_ABI=0&lt;/code&gt; 禁用 c++11 abi。&lt;/p&gt;

&lt;p&gt;当然最好的做法就是保证编译器大版本基本一致。在新开发的程序如果用到了 c++ 的新特性，升级 gcc 版本和 glibc 是十分必要的。&lt;/p&gt;

&lt;h3 id=&quot;实用命令总结&quot;&gt;实用命令总结&lt;/h3&gt;

&lt;h4 id=&quot;ldd-命令用于查找某个动态库所依赖的库是否存在&quot;&gt;ldd 命令，用于查找某个动态库所依赖的库是否存在&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ldd -r &amp;lt;lib/excutable file&amp;gt; 
# 找不到的库会出现 not found
$ ldd -r libSXVideoEngine.so
        linux-vdso.so.1 =&amp;gt;  (0x00007ffc337d2000)
        libz.so.1 =&amp;gt; /lib64/libz.so.1 (0x00007f061cf41000)
        libX11.so.6 =&amp;gt; /lib64/libX11.so.6 (0x00007f061cc03000)
        libEGL.so.1 =&amp;gt; /lib64/libEGL.so.1 (0x00007f061c9ef000)
        libGLESv2.so.2 =&amp;gt; /lib64/libGLESv2.so.2 (0x00007f061c7dd000)
        libpthread.so.0 =&amp;gt; /lib64/libpthread.so.0 (0x00007f061c5c1000)
        libblend2d.so =&amp;gt; /home/seeshion/workspace/SXVideoEngine-Core/Render/../../SXVideoEngine-Core-Lib/blend2d/linux/lib/libblend2d.so (0x00007f061c187000)
        libfreeimage.so.3 =&amp;gt; /lib/libfreeimage.so.3 (0x00007f061b8ac000)
        libavcodec.so.58 =&amp;gt; /lib/libavcodec.so.58 (0x00007f06198b6000)
        libavformat.so.58 =&amp;gt; /lib/libavformat.so.58 (0x00007f06193e1000)
        libavutil.so.56 =&amp;gt; /lib/libavutil.so.56 (0x00007f06190bd000)
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;nm-命令用于读取库被导出的符号&quot;&gt;nm 命令，用于读取库被导出的符号&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nm -gDC libSXVideoEngineJni.so | grep -i license
0000000000008110 T __ZN13SXVideoEngine6Public7License10SetLicenseEPKc
0000000000008130 T __ZN13SXVideoEngine6Public7License13LicenseStatusEv
0000000000008190 T __ZN13SXVideoEngine6Public7License19IsVideoCutSupportedEv
0000000000008170 T __ZN13SXVideoEngine6Public7License26IsDynamicTemplateSupportedEv
0000000000008150 T __ZN13SXVideoEngine6Public7License26IsStadardTemplateSupportedEv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;readelf-用于读取-elf-文件的相关信息&quot;&gt;readelf 用于读取 elf 文件的相关信息&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ readelf -d libSXVideoEngineJni.so | grep rpath
0x000000000000000f (RPATH)              Library rpath: [/home/slayer/workspace/SXVideoEngine-Core/Render/cmake-build-debug:/home/slayer/workspace/SXVideoEngine-Core/Render/../../SXVideoEngine-Core-Lib/blend2d/linux/lib]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;cfilt-用于获取符号的原始名&quot;&gt;c++filt 用于获取符号的原始名&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ c++filt __ZN13SXVideoEngine6Public7License10SetLicenseEPKc
SXVideoEngine::Public::License::SetLicense(char const*)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 24 May 2020 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/linux/2020/05/24/how-to-solve-undefined-symbol-when-link-dynamic-lib-on-linux/</link>
        <guid isPermaLink="true">https://dongyadoit.com/linux/2020/05/24/how-to-solve-undefined-symbol-when-link-dynamic-lib-on-linux/</guid>
        
        <category>linux</category>
        
        
        <category>linux</category>
        
      </item>
    
      <item>
        <title>如何高效的调试 ffmpeg</title>
        <description>&lt;h3 id=&quot;为什么需要调试-ffmpeg&quot;&gt;为什么需要调试 ffmpeg&lt;/h3&gt;

&lt;p&gt;Ffmpeg 作为音频编解码封装最流行的基础工具，也是一个庞大的程序，大部分使用是使用命令行去处理。但是也有更高级的应用，比如在手机端，服务端开发基于 ffmpeg 开放的 api 的应用程序。&lt;/p&gt;

&lt;p&gt;在移动端，特别是安卓端，只要有音视频的处理，基本是离不开 ffmpeg 开放的 api 。在服务端进行视频渲染解码，封装转码也需要ffmpeg。&lt;/p&gt;

&lt;p&gt;但是在熟悉精通整个 ffmpeg 的大部分接口和音视频相关基础之前，几乎所有人都会遇到 ffmpeg 接口返回的错误码，比如 -1, -22。一般的处理情况都是去看 ffmpeg 提供的 examples, 或者再次搜索一下其他人有没有遇到同样的问题。&lt;/p&gt;

&lt;p&gt;但是 ffmpeg 返回的错误码是公用的，比如 -22 表示 invalid argument, 但是到底是哪一个参数没设置正确， ffmpeg 根本没有任何提示。对于这种问题，供刚入门 ffmpeg 的童鞋的解决方法，要么用排除法，一个一个的方式去试，幸运的时候能试出来，但是试不出来是常态，可能会在这样一个问题上浪费几个小时，甚至几天的时间。&lt;/p&gt;

&lt;p&gt;所以需要找到更高效的方法。&lt;/p&gt;

&lt;h3 id=&quot;如何高效调试&quot;&gt;如何高效调试&lt;/h3&gt;

&lt;h4 id=&quot;1-让--ffmpeg--打印-debug-级别的日志&quot;&gt;1. 让  ffmpeg  打印 debug 级别的日志&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在调用 ffmpeg 相关函数前 设置 ffmpeg 打印的日志级别为 debug
av_log_set_level(AV_LOG_DEBUG);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在运行程序时， ffmpeg 会打印所有调试信息，这时候就是要找到可能的反应原因的错误信息，但是我们也有很大可能还是找不到具体原因。&lt;/p&gt;

&lt;h4 id=&quot;2-编译带完整debug-信息的-ffmpeg&quot;&gt;2. 编译带完整debug 信息的 ffmpeg&lt;/h4&gt;
&lt;p&gt;在使用 ffmpeg 接口出现了问题时，如果能通过 gdb 断点进去 ffmepg 相关的文件去调试，这对有助于快速定位问题。&lt;/p&gt;

&lt;p&gt;但是需要我们手动编译带 debug 信息，并且去掉编译优化的 ffmpeg 库：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure \
    --prefix=&quot;/usr/&quot; \
    --pkg-config-flags=&quot;--static&quot; \
    --extra-cflags=&quot;-I$HOME/ffmpeg_build/include&quot; \
    --extra-ldflags=&quot;-L$HOME/ffmpeg_build/lib&quot; \
    --extra-libs=&quot;-lpthread -lm&quot; \
    --bindir=&quot;/usr/bin&quot; \
    --enable-debug=3\
    --disable-optimizations \
    --disable-stripping \
    --enable-shared \
    --enable-pic \
    --enable-gpl \
    --enable-nonfree \
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;–disable-optimizations 用于去掉编译的优化，这样可以避免在 gdb 调试时，变量出现 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optimized out&lt;/code&gt; 的提示&lt;/p&gt;

&lt;p&gt;–disable-stripping 禁止去掉 gdb 所需的符号信息&lt;/p&gt;

&lt;p&gt;编译出来的库，就可以使用 gdb 跟踪具体在 ffmpeg 中的哪一步出错，能快速定位问题。&lt;/p&gt;
</description>
        <pubDate>Sun, 24 May 2020 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/ffmpeg/2020/05/24/how-to-debug-ffmpeg-effectively/</link>
        <guid isPermaLink="true">https://dongyadoit.com/ffmpeg/2020/05/24/how-to-debug-ffmpeg-effectively/</guid>
        
        <category>ffmpeg</category>
        
        
        <category>ffmpeg</category>
        
      </item>
    
      <item>
        <title>CentOS 安装 nvidia 驱动, OpenGL</title>
        <description>&lt;p&gt;Ve SDK 需要兼容 nvidia 最新版 driver, nvcodec。特意组装了台式机，显卡为 gtx 1650。&lt;/p&gt;

&lt;p&gt;需要的环境如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;os: CentOS 7.5
gcc: 4.8.5.39
gpu driver: 440.82 显卡驱动
nvcodec: 9.2 视频硬编解码 SDK 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h2&gt;

&lt;h4 id=&quot;安装内核构建依赖&quot;&gt;安装内核构建依赖&lt;/h4&gt;

&lt;p&gt;nvidia 驱动在安装时需要重新构建内核以加载 gpu 驱动，需要安装 kernel-devel, kernel-headers&lt;/p&gt;

&lt;p&gt;安装的 kernel-devel, kernel-headers 的版本要严格和当前内核版本一致。否则安装过程中会出现找不到 kernel headers 的错误&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo yum -y insall gcc dkms epel-release

# 如果 yum 搜索到的 kernel-devel 和 kernel-headers 一致
sudo yum insall  kernel-devel  
sudo yum install kernel-headers

# 低版本比如 cenos 7.5 使用 yum 安装的版本与内核版本不一致
# 需要手动下载对应的版本安装，比如内核版本为 3.10.0-862

wget http://vault.centos.org/7.5.1804/os/x86_64/Packages/kernel-devel-3.10.0-862.el7.x86_64.rpm
wget http://vault.centos.org/7.5.1804/os/x86_64/Packages/kernel-headers-3.10.0-862.el7.x86_64.rpm

sudo yum install kernel-devel-3.10.0-862.el7.x86_64.rpm
sudo yum install kernel-headers-3.10.0-862.el7.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;禁用系统自带的-nouveau-驱动-可选&quot;&gt;禁用系统自带的 nouveau 驱动 (可选)&lt;/h4&gt;

&lt;p&gt;nouveau 是一个 nvidia 显卡的第三方开源驱动，一般 linux 发行版的内核都会默认自带并使用这个驱动模块。
但是一些新特性没有支持。&lt;/p&gt;

&lt;p&gt;新版 nvidia 驱动安装时会自动禁用 nouveau&lt;/p&gt;

&lt;p&gt;查看 nouveau 有没有启用使用&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lsmod | grep nouveau
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;禁用 nouveau；&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vim /etc/modprobe.d/blacklist-nouveau.conf

# 添加以下代码
blacklist nouveau
options nouveau modeset=0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;安装驱动&quot;&gt;安装驱动&lt;/h2&gt;

&lt;h4 id=&quot;下载安装&quot;&gt;下载安装&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://us.download.nvidia.cn/XFree86/Linux-x86_64/440.82/NVIDIA-Linux-x86_64-440.82.run
sudo chmod +x NVIDIA-Linux-x86_64-440.82.run
sudo ./NVIDIA-Linux-x86_64-440.82.run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;重启检查是否安装成功&quot;&gt;重启检查是否安装成功&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nvidia-smi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;检查-opengl-信息&quot;&gt;检查 opengl 信息&lt;/h4&gt;

&lt;p&gt;nvidia 驱动自带 openGL 的实现，默认随着驱动被安装。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用 nvidia-settings 查看&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nvidia-settings -g | grep -i &quot;opengl&quot;
OpenGL vendor string: NVIDIA Corporation
OpenGL renderer string: GeForce GTX 1650/PCIe/SSE2
OpenGL version string: 4.6.0 NVIDIA 440.82
OpenGL extensions:

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;使用 mesa-utils
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo yum -y install mesa-utils
$ glxinfo | grep -i opengl
OpenGL vendor string: NVIDIA Corporation
OpenGL renderer string: GeForce GTX 1650/PCIe/SSE2
OpenGL core profile version string: 4.4.0 NVIDIA 440.82
OpenGL core profile shading language version string: 4.40 NVIDIA via Cg compiler
OpenGL core profile context flags: (none)
OpenGL core profile profile mask: core profile
OpenGL core profile extensions:
OpenGL version string: 4.6.0 NVIDIA 440.82
OpenGL shading language version string: 4.60 NVIDIA
OpenGL context flags: (none)
OpenGL profile mask: (none)
OpenGL extensions:
OpenGL ES profile version string: OpenGL ES 3.2 NVIDIA 440.82
OpenGL ES profile shading language version string: OpenGL ES GLSL ES 3.20
OpenGL ES profile extensions:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;安装-cuda-驱动可选&quot;&gt;安装 cuda 驱动（可选)&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget http://developer.download.nvidia.com/compute/cuda/10.2/Prod/local_installers/cuda_10.2.89_440.33.01_linux.run
chmod +x cuda_10.2.89_440.33.01_linux.run
sudo ./cuda_10.2.89_440.33.01_linux.run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;其他实用命令&quot;&gt;其他实用命令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;查看显卡信息&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo lshw -numeric -C display
  *-display UNCLAIMED       
       description: VGA compatible controller
       product: NVIDIA Corporation [10DE:1F82]
       vendor: NVIDIA Corporation [10DE]
       physical id: 0
       bus info: pci@0000:01:00.0
       version: a1
       width: 64 bits
       clock: 33MHz
       capabilities: pm msi pciexpress vga_controller bus_master cap_list
       configuration: latency=0
       resources: memory:f6000000-f6ffffff memory:e0000000-efffffff memory:f0000000-f1ffffff ioport:e000(size=128) memory:f7000000-f707ffff
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ lspci | grep -i nvidia
01:00.0 VGA compatible controller: NVIDIA Corporation Device 1f82 (rev a1)
01:00.1 Audio device: NVIDIA Corporation Device 10fa (rev a1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 13 May 2020 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/linux/video/audio%20tech/2020/05/13/centos-install-nvidia-driver-and-opengl/</link>
        <guid isPermaLink="true">https://dongyadoit.com/linux/video/audio%20tech/2020/05/13/centos-install-nvidia-driver-and-opengl/</guid>
        
        <category>nvidia</category>
        
        <category>opengl</category>
        
        
        <category>linux</category>
        
        <category>video/audio tech</category>
        
      </item>
    
      <item>
        <title>MacOS 编译最新版 ffmpeg (4.2.1) 动态库</title>
        <description>&lt;p&gt;在 macOS 下编译相对于 linux 要简单一些。由于在 macOS 下一般是开发使用，所以在编译之前使用 homebrew 安装相关依赖即可。&lt;/p&gt;

&lt;h3 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;automake 1.16.2&lt;/p&gt;

    &lt;p&gt;brew install automake&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pkg-config 0.29.2&lt;/p&gt;

    &lt;p&gt;brew install pkg-config&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fdk-aac 2.0.1&lt;/p&gt;

    &lt;p&gt;brew install fdk-aac&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lame 3.100&lt;/p&gt;

    &lt;p&gt;brew install lame&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libvorbis 1.3.6&lt;/p&gt;

    &lt;p&gt;brew install libvorbis&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libopus 1.3.1&lt;/p&gt;

    &lt;p&gt;brew install opus&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libbluray 1.1.1&lt;/p&gt;

    &lt;p&gt;brew install libbluray&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libvpx 1.8.2&lt;/p&gt;

    &lt;p&gt;brew install libvpx&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libx265 3.3&lt;/p&gt;

    &lt;p&gt;brew install x265&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libx264 r2917&lt;/p&gt;

    &lt;p&gt;brew install x264&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libxvid 1.3.5&lt;/p&gt;

    &lt;p&gt;brew install xvid&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sdl2   2.0.9&lt;/p&gt;

    &lt;p&gt;brew install sdl2&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-编译-ffmpeg&quot;&gt;2. 编译 ffmpeg&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;下载&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  wget http://ffmpeg.org/releases/ffmpeg-4.2.1.tar.gz
  tar -xzvf ffmpeg-4.2.1.tar.gz
  cd ffmpeg-4.2.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行 ./configure 检查依赖，出现 not found 请检查，依赖库是否有安装成功&lt;/p&gt;

    &lt;p&gt;以下 enable 的选项是 ve SDK 所需的，其他选项可自行选择添加&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./configure  \
  --prefix=/usr/local \
  --enable-shared \
  --enable-pic \
  --enable-gpl \
  --enable-nonfree \
  --enable-libmp3lame \
  --enable-libfdk_aac \
  --enable-libvorbis \
  --enable-libopus \
  --enable-libbluray \
  --enable-libvpx \
  --enable-libx265 \
  --enable-libx264 \
  --enable-libxvid \
  --enable-lzma \
  --enable-opencl \
  --enable-audiotoolbox \
  --enable-videotoolbox \
  --enable-sdl2 \
  --enable-pthreads \
  --enable-x86asm \
  --enable-postproc \
  --disable-securetransport \
  --disable-libjack \
  --disable-libopencore-amrnb \
  --disable-libopencore-amrwb \
  --disable-libxcb \
  --disable-libxcb-shm \
  --disable-libxcb-xfixes \
  --disable-indevs \
  --disable-outdevs 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译安装&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  make -j8 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;ffmpeg-非必须选项-按需选择&quot;&gt;ffmpeg 非必须选项, 按需选择&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;libmodplug 0.8.9.0&lt;/p&gt;

    &lt;p&gt;brew install libmodplug&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libopenjpeg 2.3.1&lt;/p&gt;

    &lt;p&gt;brew install openjpeg&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libsoxr 0.1.3&lt;/p&gt;

    &lt;p&gt;brew install libsoxr&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libspeex  1.2.0&lt;/p&gt;

    &lt;p&gt;brew install speex&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gnutls 3.6.8&lt;/p&gt;

    &lt;p&gt;brew install gnutls&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 11 May 2020 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/ffmpeg/video/audio%20tech/2020/05/11/compile-ffmpeg-dynamic-libary-on-macos/</link>
        <guid isPermaLink="true">https://dongyadoit.com/ffmpeg/video/audio%20tech/2020/05/11/compile-ffmpeg-dynamic-libary-on-macos/</guid>
        
        <category>macos</category>
        
        <category>ffmpeg</category>
        
        
        <category>ffmpeg</category>
        
        <category>video/audio tech</category>
        
      </item>
    
      <item>
        <title>CentOS 编译最新版 ffmpeg (4.2.1) 动态库</title>
        <description>&lt;p&gt;准备工作&lt;/p&gt;

&lt;p&gt;mkdir $HOME/ffmepg_build  # 三方库安装目录
mkdir $HOME/ffmpeg_source # 所有库的下载目录
mkdir $HOME/bin           # 可执行二进制文件安装目录&lt;/p&gt;

&lt;p&gt;把安装的第三方库目录添加到系统查找路径中：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    sudo vim /etc/ld.so.conf
    # 添加, {$HOME} 替换成实际目录，比如 /home/slayer/ffmpeg_build/lib
    {$HOME}/ffmpeg_build/lib
    
    # 重新加载 ldconfig
    sudo ldconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;编译依赖工具&quot;&gt;编译依赖工具&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo yum install automake autoconf libtool build-essential pkg-config gcc-c++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;第三方依赖&quot;&gt;第三方依赖&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;nasm&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cd nasm
 ./autogen.sh
 PATH=&quot;$HOME/bin:$PATH&quot; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --bindir=&quot;$HOME/bin&quot;
 PATH=&quot;$HOME/bin:$PATH&quot; make
 make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;yasm&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cd yasm-1.3.0 &amp;amp;&amp;amp; ./configure --prefix=&quot;\(HOME/ffmpeg_build&quot; --bindir=&quot;\)HOME/bin&quot;
 make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fdk-aac&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://downloads.sourceforge.net/opencore-amr/fdk-aac-2.0.1.tar.gz
tar xzvf fdk-aac-2.0.1.tar.gz 
cd fdk-aac-2.0.1 &amp;amp;&amp;amp; autoreconf -fiv &amp;amp;&amp;amp; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --enable-shared
make &amp;amp;&amp;amp;  make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;opus&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cd opus-1.3.1 &amp;amp;&amp;amp; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --enable-shared
  make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lame&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cd lame-3.00 &amp;amp;&amp;amp; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --enable-nasm --enable-shared
 make &amp;amp;&amp;amp;  make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;vorbis&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # install ogg
  sudo yum install libogg-devel.x86_64

  cd libvorbis &amp;amp;&amp;amp; -- autoreconf -fi &amp;amp;&amp;amp; ./autogen.sh

  ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --enable-shared
  make 
  make install

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;x264&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; PATH=&quot;$HOME/bin:$PATH&quot; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --bindir=&quot;$HOME/bin&quot; --enable-shared 
 PATH=&quot;$HOME/bin:$PATH&quot; make
 make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;x265&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cd ~/ffmpeg_sources/x265/build/linux
  PATH=&quot;$HOME/bin:$PATH&quot; cmake -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=&quot;$HOME/ffmpeg_build&quot; -DENABLE_SHARED:bool=on  ../../source
  make &amp;amp;&amp;amp; install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;vpx&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; PATH=&quot;$HOME/bin:$PATH&quot; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --disable-examples --disable-unit-tests --enable-shared
 PATH=&quot;$HOME/bin:$PATH&quot; make
 make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bluray&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # 安装 libxml2 
  sudo yum install  libxml2-devel.x86_64

    
  # 编译 bluray 
  wget https://download.videolan.org/pub/videolan/libbluray/1.1.2/libbluray-1.1.2.tar.bz2
  tar -jxvf libbluray-1.1.2.tar.bz2 
  cd libbluray-1.1.2/
  PATH=&quot;$HOME/bin:$PATH&quot; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot;  --enable-shared --disable-bdjava-jar
    
  make &amp;amp;&amp;amp; make install

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;libxvid&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # 通过 yum 安装
  sudo yum install  xvidcore-devel.x86_64 

    
    
  # 手动安装
  wget http://packman.links2linux.de/download/xvidcore/3187274/libxvidcore4-1.3.5-pm152.2.6.x86_64.rpm
  wget http://packman.links2linux.de/download/xvidcore/3187274/libxvidcore4-1.3.5-pm152.2.6.x86_64.rpm
  // sudo yum localinstall libxvidcore4-1.3.5-pm152.2.6.x86_64.rpm 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;sdl2&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  wget https://www.libsdl.org/release/SDL2-2.0.12.tar.gz
  tar -xzvf SDL2-2.0.12.tar.gz
  cd SDL2-2.0.12/
    
  PATH=&quot;$HOME/bin:$PATH&quot; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot;  --enable-shared 

  make -j8 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-编译-ffmpeg&quot;&gt;2. 编译 ffmpeg&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;下载&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  wget http://ffmpeg.org/releases/ffmpeg-4.2.1.tar.gz
  tar -xzvf ffmpeg-4.2.1.tar.gz
  cd ffmpeg-4.2.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行 ./configure 检查依赖，出现 not found 请检查，依赖库是否有安装成功&lt;/p&gt;

    &lt;p&gt;以下 enable 的选项是 ve SDK 所需的，其他选项可自行选择添加&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./configure \
  --enable-shared \
  --enable-pic \
  --enable-gpl \
  --enable-nonfree \
  --enable-libmp3lame \
  --enable-libfdk_aac \
  --enable-libvorbis \
  --enable-libopus \
  --enable-libbluray \
  --enable-libvpx \
  --enable-libx265 \
  --enable-libx264 \
  --enable-libxvid \
  --enable-lzma \
  --enable-sdl2 \
  --enable-pthreads \
  --enable-x86asm \
  --enable-postproc \
  --disable-securetransport \
  --disable-libjack \
  --disable-libopencore-amrnb \
  --disable-libopencore-amrwb \
  --disable-libxcb \
  --disable-libxcb-shm \
  --disable-libxcb-xfixes \
  --disable-indevs \
  --disable-outdevs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译安装&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  make -j8 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其他可选&quot;&gt;其他可选&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;opencl&lt;/p&gt;

    &lt;p&gt;系统默认没有opencl, 通常安装了显卡驱动都能加上 –enable-opencl&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;aom&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mkdir -p aom_build &amp;amp;&amp;amp;  cd aom_build

 PATH=&quot;$HOME/bin:$PATH&quot; cmake -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=&quot;$HOME/ffmpeg_build&quot; -DBUILD_SHARED_LIBS=1 -DENABLE_SHARED=on -DENABLE_NASM=on ../aom &amp;amp;&amp;amp; \
 PATH=&quot;$HOME/bin:$PATH&quot; make -j8  &amp;amp;&amp;amp; \
 sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;freetype2&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cd freetype-2.10.1 &amp;amp;&amp;amp; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --enable-shared
  make
  make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 11 May 2020 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/ffmpeg/video/audio%20tech/2020/05/11/compile-ffmpeg-dynamic-libary-on-centos/</link>
        <guid isPermaLink="true">https://dongyadoit.com/ffmpeg/video/audio%20tech/2020/05/11/compile-ffmpeg-dynamic-libary-on-centos/</guid>
        
        <category>linux</category>
        
        <category>centos</category>
        
        <category>ffmpeg</category>
        
        
        <category>ffmpeg</category>
        
        <category>video/audio tech</category>
        
      </item>
    
      <item>
        <title>在同一台linux机器编译多个 php 版本的扩展</title>
        <description>&lt;p&gt;一般 php 扩展编译安装方式如下&lt;/p&gt;

&lt;h3 id=&quot;扩展编译步骤&quot;&gt;扩展编译步骤&lt;/h3&gt;

&lt;p&gt;以扩展 ataencoder 为例&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;进入扩展目录&lt;/li&gt;
  &lt;li&gt;./phpize&lt;/li&gt;
  &lt;li&gt;./configure ./configure –enable-ataencoder&lt;/li&gt;
  &lt;li&gt;make&lt;/li&gt;
  &lt;li&gt;make install&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;编译不同-php-版本的扩展&quot;&gt;编译不同 php 版本的扩展&lt;/h3&gt;

&lt;p&gt;如果扩展需要兼容多个 php 版本，则需要在本地先编译测试，需要为不同版本编译不同的 so 包, 步骤如下:&lt;/p&gt;

&lt;h3 id=&quot;安装不同版本的-php&quot;&gt;安装不同版本的 php&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;下载对应版本的源码，比如 7.0.33 和 7.2.10 版本&lt;/li&gt;
  &lt;li&gt;分别进入两个版本的目录，编译并安装&lt;/li&gt;
  &lt;li&gt;这个时候系统就有两个版本的 php&lt;/li&gt;
  &lt;li&gt;在 ubuntu 系统上，可以使用 update-alternatives 来设置默认的 php 版本，如果没有这个工具，则可以使用软链接实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;编译安装步骤&quot;&gt;编译安装步骤&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;选定要编译 php 版本的环境&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要保持　php, phpize, php-config 为目标版本。&lt;/p&gt;

&lt;p&gt;phpize 用来初始化扩展，确定扩展使用的 php api 版本, 并且生成配置文件比如　configure 脚本&lt;br /&gt;
php-config 被　configure 用来确定包含 php 的头文件和一些库&lt;/p&gt;

&lt;p&gt;ubuntu 系统下可以使用　update-alternatives 替换, 其他 linux 发行版如果没有类似的工具，可以使用软链接替换。&lt;/p&gt;

&lt;p&gt;+　设置 php 版本&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update-alternatives --list php
/usr/bin/php7.0
/usr/bin/php7.2

# 设置 php 为　7.0 版本
update-alternatives --set php /usr/bin/php7.0

# 或是使用软链接
# ln -s /usr/bin/php7.0 /usr/bin/php
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;设置 phpize 版本&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看可用的 phpize
update-alternatives --list phpize
/usr/bin/phpize7.0
/usr/bin/phpize7.2

# 设置 phpize 为　7.0 版本
update-alternatives --set phpize /usr/bin/phpize7.0

# 或是使用软链接
# ln -s /usr/bin/phpize7.0 /usr/bin/phpize
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;设置 php-config 版本&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看可用的 php-config
update-alternatives --list php-config
/usr/bin/php-config7.0
/usr/bin/php-config7.2

# 设置 php-config 为　7.0 版本
update-alternatives --set php-config /usr/bin/php-config7.0

# 或是使用软链接
# ln -s /usr/bin/php-config7.0 /usr/bin/php-config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;设置完以上步骤后，就可以按文章开头的步骤编译安装 php7.0或其他 php 版本的扩展了。&lt;/p&gt;
</description>
        <pubDate>Sun, 16 Feb 2020 00:00:00 +0800</pubDate>
        <link>https://dongyadoit.com/php/linux/2020/02/16/comiple-php-extension-of-different-php-version-on-a-linux-machine/</link>
        <guid isPermaLink="true">https://dongyadoit.com/php/linux/2020/02/16/comiple-php-extension-of-different-php-version-on-a-linux-machine/</guid>
        
        <category>php</category>
        
        <category>php_extension</category>
        
        
        <category>php</category>
        
        <category>linux</category>
        
      </item>
    
  </channel>
</rss>
